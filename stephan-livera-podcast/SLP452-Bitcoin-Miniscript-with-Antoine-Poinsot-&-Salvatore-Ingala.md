---
title: SLP452 Bitcoin Miniscript with Antoine Poinsot & Salvatore Ingala
transcript_by: youtube_to_bitcoin_transcript_v_1.0.0
tags: ['']
categories: ['']
speakers: ['']
media: https://www.youtube.com/watch?v=D5Q7yB_txkU
---

 Antoine and Salvatore. Welcome to the show. Thanks for having me. Thank you, Stefano. So I know you guys are both building out some stuff in mini script, obviously software and hardware. And I know this is an interesting area. There's been a bit of discussion about it, but there's also been some critique about it as well. So I'd be interested to you know get into this with you guys, but maybe first if we could start what was your interest like why did you get interested in this idea of mini script? For me it was starting working on a revolt and actually having the response video developing the project and tinkering with it comes creeps and thinking well I'm not going to take the response video of writing with games scripts by hand so I need a framework to do that safely. Yeah. And for you Salvatore. And for me as well it was kind of a natural extension of the work I was already doing to support multi-signator like when I was figuring out what is the best way of doing multi-signator I figured out I figured out that a lot of the things that I was doing will actually generalize to more complex scripts. And because the possibilities of using more complex scripts have a lot of potential applications as we probably discussed I thought that I should plan that from the beginning from the get go and so that has been on the road now since like we already probably mentioned something like that on the episode last year but now it's now it's an adhesion. Yeah fantastic and so let's try to make sure we keep it accessible for people as well as we go so let's just start with a very basic what is what is mini script? I live in this one point one. Okay so mini scripts is a framework for writing beat coins craved safely. So it was created by Vitalville and Andrew Paul's trial later of Jones by Senketh Kungjardko and essentially it bridges the gap between what spending policy you want for your coins and what actually ends up being implemented in the beat coins craved. So very transphils in Bitcoin works with these coins that are out there in the open and each of this coin has a value and a small program that is attached to it and the network is enforcing that anyone can spend these coins provided that they provide the data such as the program linked to the coin executes correctly and mini scripts is going to provide you the tools in order to analyze this program. So it's going to analyze the spending conditions of the program and also it's going to give you more information about it such as suggesting resources for sensitive and important for present transaction protocols to know what's going to be the size of the spending transaction that you are presenting because if someone can somehow inflate the size of the spending transaction it could be a great issue because it could hinder the confirmation message transaction and also it's going to allow you to analyze whether this program will be spendable. We set sort-party mini-vDT which is a good thing as well more for the net 12th and full of all yourself but it's interesting and so what's really nice but to me to describe this is it's going to give you your guarantees about this analysis. So in granting trade it's two main concepts that's maybe bit complicated but trade is on it. It's read consensus soundness and soundness completeness. So in Bitcoin you have these rows these cancels just rows that are network rows and you have all these policy rows or standardness from these standardness rows are strictly the consensus rows and when we say that the spending conditions that analyze by mini-scrips it guarantees that its consensus sounds it means that there is no also way of spending this program. There's no also way of spending this coin of satisfying this program then the ones that mini-scrip to give you and standardness completeness tells you that all the spending path is given by mini-scrips are going to be spendable based on others. Essentially if you create a coin with this program you're not going to get stuck and let be able to spend it. So that's it. There is no way around spending it otherwise from someone with bad intentions for instance and you're not going to get stuck. Okay so let me try to summarize and you tell me where I'm getting it wrong. So just for people who are like totally new or relatively new to Bitcoin you might be used to sending a Bitcoin transaction and we might think oh I'm just paying to an address but really you're paying into like a script and in order to spend out of that you need to satisfy certain conditions and in Bitcoin that can be things like a time lock that could be things like multi-signature like multiple people need to sign and it could be like who needs to sign and so then what we're doing here with mini-scripped and this is again coming back to what was created by Peter Waller, Andrew Polestra and Sankit is this idea that we can have that we can more easily use complex scripting that already exists in Bitcoin today but it's just this is like the layer this is kind of like a layer that helps us analyze and communicate it to each other even if we're using different wallets like if I'm using a ledger device and some other software wallets or if I'm using a spectator DIY or maybe in the future a cold card and that we can sort of speak the same language and more easily analyze the conditions and so you were mentioning here the consensus soundness and standardness completeness so you were saying with consensus soundness you're saying there's no other way to spend those coins than what you've spelled out in that in those policies and in standardness completeness I think you're saying that basically we're checking that you can spend out of it that we're not kind of burning our coins right that we're putting them into some address that nobody can spend out of no no actually let's say we did a mini-scripped today and that it needs you know two out of the three of us that those are valid and we can't spend those coins so long as you meet the conditions right and every branch every spending condition and credit basis creeps is spendable and it's valid based and on this so all persons taking part into the scripts can spend as well so I can't try to to make a script to use both of you guys and then you just get stuck and I can't like me you if you analyze this scripts with mini-scripped mini-scripped is going to tell you yeah it's safe for all three of you to get into this script so Salvatore anything to add here? yeah maybe we'll only think a lot of that is that mini-scripped is not so much a feature for users directly but it's more a feature for for developers because it enables so Bitcoin already is programmable because you can already program the way you want your money your coins to be spendable but Bitcoin makes that actually a working practice so it will be possible to decide the spending conditions in practice which is something that so far was always hypothesized but never really done it the last scale it never was easy to do I see and so probably that comes into one of the criticisms I guess you're touching on that as well because some of the criticism I've seen online as well my friend Envy K has mentioned he's saying oh he's kind of said all right we're going to bring it we're going to bring in mini-scripped support into cold card but it's probably going to be something that two users use and what's the point of this anyway couldn't I spend that time doing more other things that are practical so I'm curious if you have any views on that on that kind of criticism yeah sure so the way I see manuscript is that it enables a whole landscape of different things that can can now be built on top right so while this can sound very complicated because there are so many possibilities some of this will be advanced use cases but some might be either very easy use cases so miniscript is not something that the users will have to handle directly and while with initially of course the first the first deployments will be on advanced tools for for people who are a bit more keen to experiment with new toys and new tools but there are many use cases where you could actually make self-casto the a lot easier than this today so the program ability becoming easier will enable both advanced use cases but also very easy use case where you can help users to do things more easily than before and we can cover this a little bit more later with some example yeah sure yeah and one other area I'm sure people might be thinking or they might be concerned well hang on if if I'm going to do all this miniscript stuff how do I verify that as a user that okay the screen my screen is telling me that it's a two of three but how do I know for sure that maybe there's not some let's say the malicious attacker or the company is building in some unknown pathway that I don't know about like let's say I think it's a two or three multi-seag with the three of us here but actually this malicious company also has their own spend condition that they can just spend on their own how do I how do I as a user protect myself against that that's why the the possibility to verify what you're signing what you're doing with me script on the screen of the device is crucial so in fact when you are going to try to use miniscript wallets on on a legit device the way it's designed is that before you start using this new wallet that uses miniscript policies you will have to inspect the policy itself like the the spending conditions and so this could definitely be a point of friction for the for the user experience of the user but this is something that you do only once when the wallet is created while you know all the future use cases you'll be able to use the fact that you're really inspected that policy that maybe you give a name to that policy and you call storage and so the next time you use the policy the device will just tell you you're spending from calls or you're receiving in calls storage so definitely there are possibilities for friction there because these things are not necessarily easy to inspect for the for the user but we are just testing so of course there are there are ways of making these things easier for the user and in the future for example we might figure out what spending policies are commonly used by people and so have additional support in terms of UX for those specific policies where you instead of showing the miniscript which is a difficult thing to understand you could name these policies in a more is to understand language for example and so yeah I think there will be a lot of iterations on getting the best possible UX but the only way we can get started is by deploying the tools in a way that's safe and we start with advanced users. Sure and so maybe we can see we can summarize that answer as there might be some well-known policies or well-known ways of executing this and people just kind of stay into those well-known pathways I mean just like today when people sort of they're operating in certain contexts where maybe they are using a specific kind of wallet like maybe it's just a basic wallet you know this kind of simple stupid so on that topic then could you explain for us what are some of the use cases that you could see people using miniscript enabled tooling for like is it inheritance is it decaying multi-seagull degrading multi-seagull what are the main use cases you guys see yeah maybe just to get back and and a praise question people nowadays don't check these creeps themselves on their signing devices so if you use dig boss if you trade and you add rights you don't check these creeps if you take while into a notsy do you not going to check the row Bitcoin scripts and the jackmalt six that is happening on your own advice you're trusting the film of your device to have implemented these templates and miniscript allows you to use it but it also allows like it allows the developer to use as templates and much more and also it allows you in find stands to infer to analyze some Bitcoin script on your device and infill the semantic policy out of the row Bitcoin script that would be unalizable for for regular user to get to get back to use use cases so obviously and Bayust and the inheritance here so that yeah maybe maybe something else is that we've been rabled with with miniscript so it wears with tameloads a tamelike path in tamelike multi-seagull as well it always having re-cove it tamelike tree cover it birth is it allows sorry something just tiling and some those sorry um yeah and also well also maybe what's very interesting about miniscript is that it's come possible so let's say that the three others want to get into some script of some salt and said we say two other smashed egregious meanings this coin for now we only think about it with one keyboard person but it could be one policy for person for instance as different you might want your personal policy to be a two out of three between three different how the wallet my say for I might want to have some salt of co-signing with the company that I trust and solitary might want to just have his home publicing on the virtual and we can come together and compose these policies and when we want to agree to spend this coin we do our little things on all sides and well essentially it makes it makes everything more powerful and composable yeah that's an interesting point so we could also point out that it's like an interoperability thing so as an example if it's in a company context you might have an individual or let's say it's a senior person in the company uh who maybe has a personal wallet but that wallet can also can play multiple roles right it might be used in a personal context but then it could also be that could also be part of a multi-seag for something related to the company as well so I guess there's like an interoperability benefit is that that's basically what you're what you're one idea you're getting out there right well what you mentioned is using the same device in different setups and what I was mentioning is more that you let's say you have a two out of three small six and what I would think is each of the key is actually not a key but i mean it's great to itself it's a great itself got you it could be a time look very very multi-seaggy sorry yeah yeah sorry you're right I think I think I explained that polybodar man is like you could have your own personal setup and in a way the mini script is indifferent to whether I just had like one single device or whether I'm having a two out of three actually in the background it doesn't really matter as long as I satisfy the condition you know the script doesn't care yeah okay and so let's talk through some of those uses as well because I think it's in I think it would be valuable for people listening just to understand like can you just talk through the inheritance idea so let's say as an example you want to leave some coins to your son but today you're still you're still using those coins now so could you just walk us through what does that look like from a policy point of view maybe maybe I'll mention a bit about this one and then perhaps if I'm one wants to speak more about how what they're building at Leana because that's different oh I could be overlapping use case I guess but so one example that has been done it rhymes for me is keep this in fact inheritance and the reason is that you could have a wallet that you're using on a day-to-day basis but what happens for example if you are not able to spend your coins anymore so that could be because you lost your key or it could be because unfortunately people died there was a recent talk at the conference in in Prague about that from Danilo Brudsoni and it was exactly about what things you can do to prevent your coins from being lost in case you you die right and one thing you could do is that if for example if you have three children you could attach to your normal spending policy which is just your hard to wallet your key you could say that after one year two out of three of your children are able to spend your funds right so that's in this way they could automatically inherit the funds without having to go through any different kind of setup like past ways of handling that would be that you leave them the instructions somewhere but of course there are a lot more food guns there because someone might find out this instruction process your seed or like that becomes a very difficult problem how to protect the seed right yeah and you can even go further like what happens if two out of three of your children don't don't agree on how to speed the funds well then you could add another key which is with the lottery and it's only active after two years right and so all these things become possible with ministry and they become almost at no cost let's say one mission just on that could you just explain is that done in a relative time lockway or with an absolute time lock so in this example let's say you've got three children does that mean from the last time you spend it's one year from then or it's an absolute time lock from the time you started the wallet so ministry supports both kind of time locks so you could say that some conditions become active at a specific time in the future which is the block number typically or you could say that if the coins don't move for a specific amount of time then some condition becomes active so in a case like this one that we just mentioned if you want a condition to be active after a year then you have to remember everyone's in a while to spend the coins by sending them to yourself so that you refresh the timer which is of course it's it's a possible source of friction but this is also something that can be handled on the UX side from the world to remind you to do that or that's something definitely we can work in the future one other question there would that also blow up the transaction size right because now we're dealing with a more complicated script does that mean you're paying more for every transaction to have that not if you use separate well naturalized if you use batteries now that yeah it's getting to increase the transaction size that's it's less you're getting to increase the customer using it because most as the data it's going to be part of the witness data that is currently is counted so it's going to increase the absolute transaction size but the virtual size of the transaction is going to increase but much less so and with separate even much much less so because you only have to reveal bottles of the screen when you're spending maybe in this discussion between a relative and absolutely something that has come up for Leanna and it's very interesting because also one drawback of using relative time-lugs is that they're limited to one year and a half roughly so see videos at a time like in blocks is only encoded in 16 bits they consensus and says it's roughly 65 000 blocks so the maximum time-lugs that you can use in relative is one year in a half so that's that's that's that's that's large but that's all large if you want something very very cold and you can use absolute time-lugs there let's see if you want all five years time like can use and I'm sort of damn like but then you have to redo your setup every time every time you have you to recreate a new descriptor to register and you're saying you both but hey if it's only every five years and also when you want to recover we're we're really if time like since you don't receive your coins on your wallet all at the same time they're not going to get a to be available at the same time by the time you want to recover so if your health on that technical and once recover maybe only part of the coins are going to be available at certain height and for the rest of the coins they will have to to wait even more blocks so that can be confusing and it's something that is that we are thinking that fully in and also for the use cases there's a race the inner tense so your using a rate tense is I get one key and I get I give one key to my hair and it's time-locked then sorry it's the DKang all six that's side of the three mentions that you have to let's say four out of five that degrades into a three out of five that degrades in two out of five let's say yeah and then maybe do you you introduce many more keys at the ends like after one year under half and you decided after one year and a half it's definitely not normal if you didn't spend the coins you can say it becomes it becomes the one out of 10 with 10 keys that you would have given to many different people to do some kind of social recovery maybe because you just decide based by this time if I didn't spend it after one year and a half it means that I basically lost it so it better a bit trusting my friends already it is then losing it completely and that's also some things that we're thinking about with Leanna many people don't want to move from cast to those services because of this very very low probability that they have from losing their coins so maybe something that we could do is that okay well the interimus is specifically for you to from losing your coins by having this recovery timeline key to us that is in any event you trust us after one year and a half if you fuck up completely but if you don't you're always in total control so you get from something that is fully custodial to something that is 99 persons known custodial but in the event of total focus you can still trust to trust the company and I find this particularly interesting to bring more people to self-custody yeah so let me summarize that and I think this is something that it may be controversial for some people but it might also help more people self-custody so it might be a debate point but I think there will be some people out there who want a who would otherwise want a custodian and so this person this company let's say it's a Bitcoin company and they may want to have this kind of deep recovery key and maybe it's you like you said it's one and a half years out or maybe it's five years out and so this let's say the new or less kind of confident Bitcoin are or new Bitcoin are who's maybe not totally comfortable to be fully self-sovereign they may like that comfort factor because they may say oh okay I'm controlling the coins but if I don't spend within you know say one and a half years or five years then this company has a deep recovery key so they I don't lose the coins I might just have to wait if I if I totally lost my keys now that may be controversial but we'll see self- with me straight you can create policies where there are many keys that are participating in this policy right and so why that's interesting because different keys can have different properties for example in how they're stored on how they are managed and so for example one use case that I'm particularly interested about is imagine you're a company that actually uses ready-move-to-the-between standards so users Bitcoin on a date-to-day basis and so it has a spending wallet that they bring with them right so they would probably bring with them a harder wallet so they can spend from this from this wallet and then in that case in that case because they use that in the field they still have to be a little bit concerned about this harder wallet being not hacked but maybe some or guesses they've been or they observe them while they put in their pin and so they then later they still do all that and so they might have access their funds right and so one thing that you can do is that instead of using this as a single single wallet you could combine this with a second factor key that could be hosted on a different machine either self-hosted or even by a service and this key can be programmed can be extracted to only sign according to the predator-mind policies for example you could say to this service well only sign at most 0.1 bit coins per day right so even if your primary key is stolen then you can put some limits on how much the hackers would be able to steal and then this you can again combine with additional recovery keys that are in deep cold storage so that this can be done in a fully trustless way compared to the service because the service is not able to spend these coins without your help right gotcha yeah so it could be kind of like a corporate policy thing that limit it's like a rate limiter says like rate limited on this way but with the deep recovery keys you can sweep the whole amount out into a certain setup and you will have different people in the companies that have different policies or different and you can do this with different keys in different spending paths that you can all combine with ministry one of the question I have is there may be some privacy ramifications here somebody wants to operate fully in this kind of mini-script inheritance paradigm like as an example you may be a hotler who has got you know coins from ten years ago and you may not want to spend or move those coins around so are these mini-script policies are they going to apply at a UTXO level and then so that means if you want to keep those policies active you're now going to have to spend all of your coins and common input ownership heuristic right because you're going to spend all of your UTXOs together does that mean you're kind of doxing a bit of your privacy to use this kind of thing uh so yes simple simple so it's yes that's it depends so if you're going to use legacy seguep let's say p2.org say each then you're going to reveal those creates and if you're using a timeline in your script let's say or if you're using a mini-script at all because most people don't you're going to have a very very small you know and only set and even more so that you're choosing your timeline yourself so even even the very videos the timeline you can actually stick out if you're using tap reach your your not going to show and change that your you have this hidden recovery path until you actually need to use it so most of the time it's not going to be shown on chain and i think what what you the question was about the patterns of cycling the coins in order to recycle the relative time looks to to restart the the collect essentially uh yes you you could see some patterns that some of the three cycling are coins but they don't have to merge all the coins themselves so it's it's a trade-off between being more transaction fees and and using one or two to two coins per transaction but yeah definitely you could you could see the pattern in the future if people are resetting coins but also is there any thought yeah gone sorry but also what's very interesting with so it opens up a lot of questions about a lot of areas of Bitcoin development and using all these new scripts for instance with coins selection so we don't have points in for never in Vienna we don't have automated coin selection but we're thinking that during the coin selection process we're going to have a bias towards all the coins so that you don't have to actually do recycling transactions to yourself but when you're spending you're just spending the old of coins to its recycles themselves and you you break these buttons and that could be done to feed you yeah so this almost brings in a new paradigm right because i think historically at least in the coin control and coin selection world it was sort of like there were as as an example people like merch right who will talk about optimizing fees and he has this branch and bound algorithm and it's kind of like you're either optimizing fees or something in the privacy world saying no no like do it all about privacy and you should like not you should be very careful which coins you spend and which ones you merge and all of that so it's almost like now we've got a third paradigm now we've got this third paradigm that you may be optimizing for functionality because you your tap script or your mini script is now dictating which coins you will actually choose to spend because i might have this old coin that's about to hit a a dig a degradation and i need to spend that now because i want to keep it in my control as an example yeah but you you could see these functions here as just being future fees you know that you're going to have to to recycle this coin anyhow in the next six months is so you might as well spend its nails that you need to make an actual payment then it's then fees of an entire transaction an additional transaction in the future I see so there's maybe some ways you could be opportunistic about and be like oh i was going to spend anyway i might as well just build in my recycling transaction to the same spend therefore my wallet is kind of keeping me in compliance over time or keeping me in the state that i wanted to be in and now that's probably also going to be an interesting challenge from both the software and a hardware perspective because then it kind of it's like how do you remind that user like does does the wallet tell you ask the phone your coin is going to come up you need to recycle it now hit this to reset like how does it work well we we have a ux box i went and they had to call it between we have an alert on the yen and the ui is telling you well the tray is only 10% of your time like duration that is left you might want to to spend this going to try start the time like or say i provide that's going to be available but surely there is a huge base for ux and ui optimization for from Bitcoin designers and i'm far from being eligible that we could use help on this side definitely yeah so i do think that because the design space is so big the biggest challenges are actually on the software wallet side there are some specific challenges for hardware wallets that you can touch basically the other one but but here really the ux issue around these things and also especially when they combine with things a lot of optimizing privacy i think that will follow mostly on the on the software wallet user and that's why actually hardware wallet support is so important because it removes the bottleneck that has been so far in trying out these things in the wild so yeah and i think another area that might be interesting is of course there's going to be commercial services around this and of course in Bitcoin there's a strong open source ethos is there going to be a possibility for people to self-manage right like to not have to use a provider and be able to like obviously today we have you know various node in a package right umbrill and raspi blitz and all of those maybe this could be like a module that you know it's like your little self-hosting module that if you wanted to run it for yourself and not have to because it's an example like what if there's like some decaying multi-sig and a company goes bust or the company you know that you were relying on as a service provider they're not there anymore now what yeah that's why this property of uh of manuscript that you can compose or add additional spending policies so important and especially on top root adding an additional spending policy for emergencies comes almost at zero cost meaning unless you use it you don't pay for it and and so in this way you can always add additional keys that you only use for recovery if the main keys that you expect to use in most cases are not available and related to something that we touched before for privacy actually there is one nice property of top root that we're not getting too technically into how top root works but the way top root transactions work is that you combine one spending policy which is just one key together with an arbitrary number of policies that are scripts and so scripts could be manuscript for example right and the nice thing is that actually because of the properties of snorzeignator argon you can replace any key with some complicated protocols that do basically multi-signator but only using one key on chain right and so this is nice because in many of these multi-party signing protocols if all the parties are participating they know if if you're able to to use one of the spending conditions right and so in that case if you intend to use one of the spending conditions as long as the participants are available and are online they can just cooperate with you to use the main spending condition which is the the key path and so the scripts will never be revealed on chain so this has huge implications for privacy and while it will take a long time to develop like that's the end goal of where all this is going in my opinion to have these spending conditions that they are able to condition how the coins can and will be spent but in most cases they will not have to be revealed on chain. One of the concept that would be interesting just from what I was reading this is term descriptor templates so can you tell us what is that and why is that useful here? Yeah the idea of using the script for templates or something like that has been kind of rediscovered over in many different settings and for me in this idea that I'm developing of what I call wallet policies the idea came out while I was trying to support multisignor to in the best possible way for for ledger hardware wallets but then while realizing that the same problems will apply more general to to miniscript then I try to to make it completely independent from the specific application and make it fully general so that will work for arbitrary policy right? And so the problem that it tries to solve is the following. There is this language called output descriptors that is basically able to describe all these spending policies that you can use and you can combine that with miniscript that basically extends output descriptors and so this allows interoperability because any software that understands descriptors will now be able to understand how these spending policies work, how to understand how these things should be signed and how these things will work on chain and so on how to estimate the fees for this transaction and all the necessary things that wallets need to do but the problem is that so there are a few problems though. Out to descriptors are a very general language and so they are a bit too general meaning they can describe sets of scripts that are not how typical software wallets actually manage the wallet accounts. For example if you take the typical wallet let it be single-segment or multi-signator the way they handle these scripts is that they generate basically two sequences of possible scripts that correspond to the addresses and those are the receiving addresses and the change addresses. The receiving addresses are the addresses that you will give to someone who wants to send you money and you try always to give in your address because otherwise people can basically you would link some information about how you use money and people would able to link payments right. While the change addresses are basically addresses where you send money back to yourself because without getting into how exactly the eutectional works but when you spend some coins you always have to spend them in full and so if you don't have a set of coins that matches exactly what you want to spend what you do is that you send whatever is the amount you want to send to your distinct array to the receiver and then you send some money back to yourself and those go into this change addresses right and so what a software wallet considers an account is basically a chain of these two chains of addresses. And so wallet policy is kind of built on top of descriptors and in the mr.t by creating a standard language that software wallets can use and it's very close to descriptors so it's very easy to convert from wallet policies to descriptors or from descriptors to wallet policies that are supported and by creating by kind of forcing the pattern that anyway wallets are using nowadays you avoid using scripts that are not following this pattern unless you have specific resource to do it and another reason that wallet policy is another thing that wallet policy tries to address is that more specific to the usage of these things in in other wallets and so as we mentioned before when you use wallet policies and this is already true for multi-signator when you start using these policies you need to be able to verify on the on the hardware wallet exactly how the policy looks like and so that you know exactly what you're doing and the reason that's important is that your computer might have some malware and if the computer has malware they could change the policy and so for the hardware wallet is not enough to verify that your key is in this policy because if the malware changed the policy they could control more keys than new for example and so or even in multi-signator they could control enough keys so that you are unable to spend your funds and so in this way they could ransom you to say hey if you want to see your Bitcoin again you give half to me right and so to prevent these kind of attacks you need to be able to inspect policies exactly on the screen of the hardware wallet so one of the things that wallet policies try the this sound that the time trying to propose a wallet policies tries to do is to make this descriptor templates as short as possible and also to separate the descriptor templates that kind of specifies the structure of the policy from the the public keys which is another thing that is also part of the wallet policy but it's easier to inspect these two things separately so when you register a wallet policies on a ledger hardware wallet you will first inspect the descriptor template which is the the policy which is a structure of the policy which is like a multisigator two out of three or or a second factor between Mikey and some other key right and then on a separate step you will inspect exactly what are the public keys so one or more of these public keys will be your own but keys while some other keys will be from or the parties or from some service or something and so yeah I'm proposing that as a standard because I believe it solves problems that any hardware wallet implement in these things will have and plus it makes it a natural language to agree on a common grounds for all the software wallets. I see yeah because as I understand some of the critiques and maybe going back to what Envy Kay from CoinCart was saying is he was saying there's all this complexity here and so they want to build something safe they don't want to put their customers into you know as I'm sure you don't either anyone nobody wants to put their customers into like a dangerous position but then that means there's a lot of work on the manufacturer the software engineer to make sure it's safe and if there's all this complexity in there you know but I can understand from your perspective you're saying this is actually something that maybe it helps ease some of that or at least make it easier to assess what is they find the user what are my signing and what am I saying yes to and hopefully you know not being susceptible to a ransom or some other kind of malicious signer attack there so could we talk a little bit about what it looks like from a software side as well so Antoine could you just walk us through what does it look like on let's say today on Leana what does it look like today when you want to set up mini script yeah maybe just again to get like and when what you just mentioned about it's had a complexity it's it's important to you to remember that it's actually it's beef coins that is complex and mini scripts that makes it safer to use it's not the other way around why not making things more complex than tracing minis with we make them valuable um yeah for so it's in two parts mainly you have to first create your output descriptor which supports manuscripts and then you you can use your wallet so typically you would run in the internet uh it would pop up what we call an installer where you have to choose the spanning policies that you want for for your wallets for now we only support one primary key and one primary key using store is very simple you just plug let's say your first signing device get the expert for understanding device install offers primary key get the expert for the secondary keys the timelark key through your current key and you choose as a number of likes before the record rekey becomes available and then you just go through the steps it checks your connection to you and between the and everything that you will ignore what it would do and then you can get to the install and you can also have friends installer import a descriptor that you would have created on another wallet and recover from a descriptor and you can let's say if you are recovering from your backup you input the descriptor you take your recovery key and you can sign a recovery transaction in the future and sets one of the big UX challenges that we're going to face since tomorrow is going to get much more complex because even as I've ended up in the amount of working to have the release of multi-c so you'll be able to use multiple keys in each of these two path is so multiple keys as primary keys and multiple recovery keys and then in the future working cap multiple path is so you can have multiple keys and more than two path test timelark path says so instance file in your game also again it becomes quite a mess and install if you just put everything on it and never end up on the bullfucker user and so just on liana then is the idea that you can like the main wallet is like a hot wallet and then the recovery key is like a hardware signing device or like can you just walk us through what you're currently able to do and what you're planning to do too only we're only support signing devices in again we don't have any had keys support we're going to edit for the next release that is coming up for the next for the end of the month so next for years of going to have multi-c plus had keys I see it mainly as just make it easier to test test it but you probably don't want to to use had keys for any substantial amounts anyways so yeah fair enough and Salvatore can you tell us a little bit I'm not sure if you know if this is built into ledger live yet or is that coming could you tell us what it looks like in ledger live now at this time it's not a plant to integrate this feature in ledger live it's more like supporting something for for the ecosystem and then people build new things and one of the exciting things is that because the design space is so big like I we already mentioned a bunch of applications we could mention more and I'm sure when you're from now we can look back and people are implemented maybe 10 20 different use cases that we didn't think about like one example is like few months ago I learned there is this company Angor watch I'm welcome to this right one hand yeah and so they were building something to do insurance on on Bitcoin right and they learned about manuscripts and they just figured out themselves that with miniscape they can do stuff that is useful for the use case because since you have doing insurance they can tell the users that they will do insurance on their assets but they won't that to aggressively they are the assets with specific ways we just believe it so you're not something that I will ever think about but people will find use cases for these things and people will build useful things that's my point yeah so I could see use as you mentioned insurance obviously they might want to use that to help de-risk the way coins are stored it could be applied in a corporate context right as we've mentioned the corporate or business context where multiple people need to have access to coins it could also like you mentioned inheritance maybe even a family maybe a family might want like maybe not today but you know let's say after this has been built out a family may want to do some kind of miniscript policy together and in that way jointly manage their coins the simplest thing how do you defend yourself from a final range attack right you can you can send coins to wallet that you control but you cannot spend for a year that's very simple right right so you can have like a panic button right you can sort of have a like a i'm under attack if you're really not don't plan to spend most of your assets you could leave 10% out and send 90 percent to wallet that you yourself cannot spend for a year right yeah that's an interesting idea and then I don't know maybe you would have some kind of emergency unlock with multi-seag and things like this 20 small companies but then what if with a if I come with a range and I make you pre-sign the transactions that is going to be invaded in six months and then it's basically a race between me in six months is a new well that's that's because since you use top root you can hide another spending condition on the script with a different key it has a shorter time lock right now yeah well actually on that let's talk a little bit about the taproot app like aspects because as I understand me script was pre-taproot right like it was created pre-taproot so what's going to change in a taproot context I know we've mentioned it across our conversation but if you could just summarize for people what are the taproot implications of having me script so you're going to for the using match bigger scripts you are going to afford from the privacy but just let's say using actual complex scripts because you're not going to reveal them and I think it's the main point of using taproot for a familiar good lot user is that you can have all these hidden paths is spending passes set you would only use in case of emergency but also technically it removes a lot of the bounds that were present on the legacy scripts such as the number of maximum numbers of operations that can happen in a script so you can have fault having larger scripts and it also removes some maybe active vectors in the scripts by making some roles that were only standardness rules that were enforced by must-nudes and the network that's not well not part of Bitcoin by actually enforcing them by consensus so we can rely on them within the scripts and so yeah if I didn't miss anything interesting because I saw some of the some of the haters were saying taproot was not really doing March or adding March to the network but I mean this is an obvious case where maybe there's actually new functionality being brought by taproot so you know the lightning guys are using they're looking to use taproot and I know Lalo and the lightning labs team are looking to have taproot channels and they're working towards that and this is another example where taproot is actually bringing a new functionality that could bring all these new features or make it more feasible for people to do so but I mean the jury's still out like you know we still need to see companies actually building out and making these things but I think it's an interesting example of actually here's an actual taproot benefit yeah I have no doubt that use cases on taproot will with flocksune as soon as the tooling is built and people are expecting taproot usage to grow before the tools are built like well there is no reason to switch the taproot before the tools are built you can do the same things on site with yeah okay so looking forward like do you have any other ideas on where you would like this to go is there is there any other directions that we have and mentioned so far that you you know think or any other important points that you think about this that we haven't covered so it's a sleep rate slow because I don't know mature bird it but I guess I'm interested in that's that's something that we were discussing just before to show it so that for me I'm interested in how covenants would be integrated into manuscripts so on this side if Sam FC multiple listeners want to have a look and draw and think it have an extension of manuscripts for equities or for elements and that takes into manuscripts Sam FC introspection primities that are made possible by the elements scraping system and that's yeah that's interesting basically you could say you mean you can only spend immediately but as long as the output at the secant indexing the spending transaction at this value or that you can only spend after six months is if you spend with a transaction that I don't know as a single input so you can introspect into spending transactions that's interesting and that relates also to those our covenants proposals what are the limits what can really be encoded into a descriptor for covenants for instance and let's show with all the information for for night for the proposal of sanitary could be encoded in a single descriptor if we need more powerful language for this or yeah there's nothing to an interesting thing with descriptors that we're implementing descriptors today but it's not something that it's setting stone meaning we can always add new features we can always always like if a future thought fork adds new features to Bitcoin then you could expand the output descriptor language to implement these new features and so having this language of available we make it a lot easier to extend the language and roll out new features because there's always been a pain point like from the switch from the legacy to side with from the switch from side with to talk with and so on every everyone of this upgrade has always been very slow in adoption because it was very long and time-consuming to build the tooling while I think now we are getting to some solid foundations that are much more easy to extend a much easier product okay great so yeah let's let's just summarize like we've gone through a lot of stuff and I know this is probably a bit more of a technical episode so hopefully people people might have to kind of go back over but let's just kind of quickly give a you know high level summary here right like manuscript is this way of making it easier to assess and interoperate between wallets in terms of Bitcoin scripting and make it so that maybe you're less likely to have like a vendor lock-in right because you can have mini-script and it's like cross-compatible in a way so that's that's that's useful that's handy and it makes it easier for engineers and entrepreneurs to build something out in them that would have previously been too complicated or maybe that was in the too hard basket before whereas now with mini-script some of these ideas become feasible and maybe it makes it easier to do this inheritance planning time locking business context so I guess that's kind of how I would summarize it do you guys have any other you know closing thoughts what why should listeners care nothing said maybe something that we didn't touch on that's important yeah I would be descriptors even less and especially less technical listeners should look into it with descriptors it's a it's a way of making your backup explicit because the recovery processing Bitcoin is not only that being able to sign for coin it's about being able to locate the coin is the first place in in the U.G. Excel sets. Sorry well when I took this energy of the value transfers a bit going being just coins in the open with value and a program attached there is about 80 million of these coins promptly so if you do not know in what scrapes your key was used your key backup is useless and frankly we rely on implicit information it's good enough in most situation that when we're talking about people's many must is not enough we it's happy to express those a way of making these backups explicit so that you know well your key was used and you have your private key to sign your for the coins that you're located with the backup so yeah closing starts looking to back up with descriptors and try out Leanna and we need designers for Leanna it's going to be an S for the installer Salvador yeah Michael's in thoughts so we all got excited listening to Andrea Santonopoulos mentioning how Bitcoin is programmable money and I think a manuscript changes that from programmable in theory to programmable in practice so Bitcoin companies I think everybody should look at miniscapes and what miniscript can do for them Fantastic well thank you guys for joining me I'll put all the links in the show notes so thanks Antoine and Salvatore thank you thanks for having us
