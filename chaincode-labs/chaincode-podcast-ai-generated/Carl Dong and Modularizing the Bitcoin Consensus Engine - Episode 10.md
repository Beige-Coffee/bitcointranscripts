---
title: Carl Dong and Modularizing the Bitcoin Consensus Engine - Episode 10
transcript_by: Whisper AI & PyAnnote
categories: podcast
tag: ["Carl's De-globalize ChainstateManager PR", 'Async Block Processing PR', 'Deglobalize class of chainstate manager (g_chainman)', 'AssumeUTXO', 'global variables and main', 'scripted diff', '0.8 upgrade consensus failure', "Jorge Timon's libconsensus project", 'current libbitcoinconsensus only does script verification', 'the case for multiple implementations', 'ABI']
---

Chaincode Labs podcast: Carl Dong and Modularizing the Bitcoin Consensus Engine - Episode 10

SPEAKER_02: It can't be that people try to cram all of the features that they want into Bitcoin Core. But if people have drastically different ways that they want to implement their node, having a library is so much more useful than telling them to fork the code base.

SPEAKER_00: This is part 2 of our conversation with Carl Dong where we discuss isolating the consensus engine. If you're looking to learn more from Carl about bootstrappable and reproducible builds, you should go back to episode 9. Enjoy!

SPEAKER_01: you

SPEAKER_00: You want to talk about isolating the consensus engine?

SPEAKER_02: Yeah, sure. So more recently, I've dove into the codebase a little bit more. That sort of started with looking at Matt's async process new block work and playing around with that, looking at, you know, and learning from that, you know, how do you make a change to, you know, the core engine of Bitcoin core.

SPEAKER_00: Can you talk about that PR a little bit and what it would do?

SPEAKER_02: Yeah, so basically right now, very simply, right now when we process new blocks from a peer, we basically block everything. And that is bad in a software that's supposed to be performing, and also it's bad for embedded systems or systems with less processing power. And the basic gist of it is that asynchronous processing a new block allows us to be able to process new blocks somewhat asynchronously. And anyway, so I looked into that a little bit, but I thought that one of the things that I had talked about with Matt and Corey a few years ago was very interesting, which was modularizing our consensus engine, capturing what our consensus engine is right now, as ugly as it is, with warts and all, and then seeing if we can perhaps physically separate it from the rest of the code base. But obviously, those are much future steps, right? But right now, our consensus engine, one of the things that I see as the major problem is that we have so much global mutable state. So having global mutable state is really bad, because when you're looking at a function, you consider its inputs to just be its parameters and maybe what class it's a member of, but you don't consider that global mutable state can influence the execution of functions, of macros, of everything greatly. And for something as important as our consensus code, we should probably modularize it such that it relies on less and less global mutable state and be able to just work nicely. And after we have modularized it, perhaps we can separate it out perhaps into a library, like people said about the Bitcoin consensus a few years ago, perhaps do something else. But that's sort of the first step. And so this is why recently I've been working on this PR to deglobalize a class called ChainStateManager. ChainStateManager was introduced as this manager class that manages multiple chain states. And basically, chain states encapsulate our view of chain and the UTXO set and blocks and.

SPEAKER_01: So for example, if there's stale blocks or two competing chain tips, that would have multiple chain states.

SPEAKER_02: That would actually be one chain state, but two chains, I think. No, sorry. One chain state, one chain, but two block trees. I think that's what it is. So multiple chain states. I'll explain why there might be multiple chain states, where we have multiple chain states in the case of a CMUTXL. So Chain State Manager was introduced for a CMUTXL, where we'll have multiple chain states that are sort of progressing, and the active one may switch between one or the other. And so that's why we have a chain state. And so basically, if you look at what our consensus engine encompasses, that it basically encompasses Chain State Manager and all the objects that it owns and references. And so that is what I'm trying to encapsulate and trying to de-globalize. Because before, we had this one global G chain man that was referenced from everywhere in the code base, and that was getting to be a mess. And also, one of the things that's interesting, perhaps, for people who are into the nitty-gritty about C++ is that global variables cannot be instantiated with things that are determined, basically, after main starts. So that's why we've had some very weird ways to initialize these global variables, where we initialize an empty one globally, and then in main, we want to make sure as soon as possible to initialize it with actual content. So there's a three, four phase initialization. And we also initialize it differently between Bitcoin D and then Bitcoin Qt and our test code. And so the combination of having a three, four phase initialization and those means you can have discrepancies between the test code and the main code when you're initializing stuff. And it leads to a lot of bugs that are very hard to reason about.

SPEAKER_01: Sure, yeah. Because it's so hard to reproduce? Yes. Yes.

SPEAKER_00: Yes, yes exactly nice callback This is a lot of code that you're that you're changing so right I don't know the PR that we're talking about is 2158. It's 82 commits and 800 lines of sensitive code. So how do you test this? How do you structure this for code review like right? How do you how do you make sure that we're not breaking Bitcoin?

SPEAKER_02: So, yeah, so this is one of the things, again, I mean, this is sort of like, you know, the mantra stands of, like, getting it to work in a hacky way is very easy, but getting it to work in a nice way, especially if you're needing, you know, review from others is much harder. So, I had this, you know, working, you know, a long time ago, but I needed to structure it because of how much of the code I was touching, I needed to structure it in a way where every commit made a lot of sense. The review experience that I wanted for this was for reviewers to be able to look at every commit and be like, this is trivial, this is trivial, this is trivial, this is trivial, and by the end, they're like, oh, I just reviewed a bunch of trivial commits. In aggregate, they do something big, right? And so that's why I have this piece of paper at home, I think I threw it in the trash now, I should have kept it. I have this piece of paper at home where I basically mapped out all the calls within our code base that relates to Chainstay Manager, and it looked like somewhat of a tree, and I started pruning the tree from the bottom up, right? Because from the bottom, these are direct references to G Chainman, and so I just said, okay, if you're referencing G Chainman, then you should probably take in a parameter that is Chainman and use that instead, or something like that. So I basically pruned the tree all the way up, and each commit prunes one node all the way up to the top where I removed G Chainman and all of its things. In the middle, I saw that one of the things that could lead to problems is the notion of the active chain state. Most of these functions, what they reach for is the chainman's active chain state, right? But now you're passing in a parameter that is chain state, but you have no idea which chain state this is. This could be the active one, this could be the inactive one. So the way to make sure was I put in a lot of what I call review-only assertions. So I put in all these assertions that were like, okay, let's assert that this chain state that's being passed in is the active chain state, and I put all these in so that reviewers can run the code themselves and see that there was no assertion error or nothing failed. And then in the end, I have one quick scripted diff to just get all of them out. And scripted diffs were really helpful during this, especially with large refactors like this where you're like, I'm inserting a parameter. Oh no, it's being called from 30 different places. Being able to do a scripted diff is not only easier for me to rebase, it's also easier for reviewers because they can just look at the said script and be like, okay, yeah, that makes sense.

SPEAKER_00: This episode is brought to you by the Argentinian peso. Your savings are safe with us. Except for that time in 1985. Or that time in 89 when it inflated by 200% in July alone. But this time we've got it. Well, except when we abandoned the whole system in 2001. But things are really looking good now. The exchange rate is 83 pesos to the dollar. Though on the black market it's about 195. Anyways, the Argentinian peso is where you should keep your money safe. We've got it this time. Can I ask some more meta questions? So this path is littered with dead bodies of people that have tried to encapsulate our consensus engine. First of all, can you just tell us like consensus engine seems very deliberate. Like that's a that phrase doesn't sound that's not something I've heard before. Yeah. Where does that come from?

SPEAKER_02: It comes from the need to not say consensus critical code because people have a very specific understanding of consensus critical code. People have very differing understanding of consensus critical code. If it's leveled GB part of consensus critical code, they might have different answers. It was in 0.8. Right, right. Exactly. It was in 0.â€¦ That's for sure. That's for sure.

SPEAKER_00: That's by the way, that's the reason that's funny. Can you can you say why that's funny?

SPEAKER_02: I think it's 0.8, an upgrade in level DB from BDB to level DB caused a bug because of how many locks was available in each one, the limitation on locking. Yeah, so yes. So it's very deliberate and I get this phrase from Matt who texted it to me and I was like, I'm going to steal that. I'm really going to steal that. Consensus engine as in, consensus as like our consensus code as it is right now, everything it depends on and all the auxiliary things that are needed for it to work, whether it be caching or storage or whatever. So that's a very deliberate phrasing that I'm using to make sure that I'm being correct with how I say things. Cool.

SPEAKER_00: So you're slowly teasing this out and unbundling it. Can you tell us about others who have made past efforts? It sounds like Matt started doing this. But tell us a little bit about what if you've made past efforts.

SPEAKER_02: Yeah, yes. So, you know, going chronologically backwards, I think the last effort was Matt's effort. And Matt is the one who introduced sea chain state. Before sea chain state, there was just what I would like to call a primordial soup of global mutable state and validation. And he brought a lot of that together into sea chain state. And that was supposed to be exported as a lib bitcoin consensus, but that sort of never happened. But that is one of the first steps. And you know, I stand on the shoulders of giants. And these are, you know, advancements that make my job much easier right now. And I think before that, I think Jorge had a big project to sort of complete our lib bitcoin consensus into something that is more whole and encapsulates the consensus engine. Perhaps a good piece of context to give right now is that we do have a lib bitcoin consensus right now. And our lib bitcoin consensus right now only does script verification. It doesn't do anything else. It doesn't connect blocks. It doesn't do anything else. It's not a full consensus engine. And again, these are, to me, lofty goals that are pretty far away. I want to look at what are some concrete steps we can move towards a world where it is possible to do something like that to complete a library. And what are some concrete steps that would benefit our code base right now that moves towards that. And so as we go along, I think it is foolish to try to think about what would a perfect lib bitcoin consensus look like or what would a perfect organization look like. I think it's good to take concrete steps that benefit us and then take a look from there. Once we get there, we might have very different understandings of how the code base should work. Maybe we discover new things and we just take it a step at a time and learn and talk and discuss.

SPEAKER_00: Wouldn't multiple implementations come in handy for this? I mean, if we have sort of, we have to copy the bugs. Yeah. As a part of consensus. But wouldn't it make sense for, wouldn't that be handy right now to just have, like, other people who are thinking about this and trying to isolate what consensus is? I'm sure we do this when it's.

SPEAKER_02: Yeah. So one of the understandings of an ABI is like the bug interface, right? And Bitcoin is unique in that you sort of want to, it's a consensus system. So you almost want to replicate the bugs. It sounds very weird to say, but that's basically what it is. You have to. Right. Exactly. You have to basically replicate the bugs. So one of the things about being able to, and again, this is so far off, but if someday, maybe in the next 10 years, who knows? We get to a place where we have a library that other applications can pull in and get a consensus engine that matches exactly with Bitcoin cores, then they can implement alternative implementations of Bitcoin without fear of being out of sync with the main chain. They can implement alternative implementations with different policies, different priorities.

SPEAKER_01: Cloud services, for example, one of the things that were introduced by previous alternative implementations was that you could serve unconfirmed transactions, or could serve the UTXO set, parts of the UTXO set. Yeah, exactly. Yeah. Or think about block explorers, yeah, Bitcoin Core does not have a full transaction index by default. Exactly. And you can start it with TX index, but then you still don't have address balances, for example.

SPEAKER_02: That's exactly it, and that touches on one of the things that I felt was very compelling to me when I thought more about why I want to do this. It is a sort of a technical solution to a somewhat social problem, because it can't be that people try to cram all of the features that they want into Bitcoin Core, right? That's sort of unmaintainable, and that's perhaps not what we want. We don't want a hundred different indexes just to serve every single need, but if people have drastically different ways that they want to implement their node, having a library is so much more useful than telling them to fork the code base, because forking the code base means a major rebase every few years. That's just not really a practical thing to do.

SPEAKER_01: And you inherit all the design decisions. Exactly. You have to move away from that, right? Right, right. Bitcoin course code base is rather quirky. Oh, for sure. Yeah.

SPEAKER_02: That's for sure. That is for sure.

SPEAKER_00: Another lesson of why not to put a proof of concept into production.

SPEAKER_01: Well, I don't know, it kind of works, right?

SPEAKER_00: does any any parting shots any other things to talk about in terms of the modularizing our

SPEAKER_02: Modularizing? I mean, I would just encourage anybody who's listening to this to review the code. I've made it so that every commit is somewhat trivial to review, and the more involved ones have very long commit messages just to describe why it is the way it is. Cool.

SPEAKER_01: Does a fool not need to have a wallet? Does a fool not need to have a wallet?

SPEAKER_02: Yeah, maybe not, maybe not, maybe that's the thing that doesn't work.

SPEAKER_00: certainly doesn't need a GUI. All right, Carl, thank you for joining us. I know it's been a, we've been trying for months to get you on, but I appreciate the conversation.

SPEAKER_01: Thanks for making the trip. Love you guys.

SPEAKER_02: Bye.

SPEAKER_01: Nice. Well, we hope you all enjoyed part two.

