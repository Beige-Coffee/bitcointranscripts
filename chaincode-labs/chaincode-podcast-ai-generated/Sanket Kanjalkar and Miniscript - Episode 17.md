---
title: Sanket Kanjalkar and Miniscript - Episode 17
transcript_by: Whisper AI & PyAnnote
categories: podcast
tag: ["What's Miniscript?", 'Partially Signed Bitcoin Transactions (PSBTs)', 'Analyzing PSBTs with Miniscript', 'How do Output Descriptors relate to Miniscript', 'Implementations of Miniscript', 'Semantic analysis of Scripts', 'Non-malleability of miniscript', 'Miniscript Policy', 'Rediscovering HTLCs', 'Miniscript uses', 'Removing script limitations with Taproot', 'Generic signing', 'Future work', 'The role of policy', 'Miniscript website', 'Rust Miniscript', 'Miniscript C++ implementation', 'Gramtropy', '##miniscript on Libera Chat']
---

Chaincode Labs podcast: Sanket Kanjalkar and Miniscript - Episode 17

SPEAKER_01: Welcome back to the chain code podcast. Hey, does this March and Jonas March? This episode sounds a little bit different when we actually get into the meta thing, so why is it different?

SPEAKER_02: And d- I did a little bit of field reporting. So I recorded an episode myself for the first time. We were using different equipment, different environment. I think the sound could have gone a little better, but I recorded a great episode with Sanket.

SPEAKER_01: Cool. Yeah, it was really great to have Senkit on, and you really get into the weeds in this mini-script stuff, huh?

SPEAKER_02: Yeah, we explore a little bit the intersection of Minuscript with other developments recently. So PSPTs, output descriptors, Minuscript policy versus Minuscript. I think especially if you're into wallet development or addresses and that sort of stuff, this one will be fun.

SPEAKER_01: One of your many nicknames is the wallet whisperer. So I think it'll he'll really be showing your colors here Thank you Alright, I hope you enjoy the episode.

SPEAKER_02: Hi, I'm sitting here with Sanket Kansarkar, and I'm gonna talk to him about Minuscript and Minuscript Policy, and his work that he's doing on making it easier for us to implement more complex contracts.

SPEAKER_00: Hi, I'm Sanket. Nice to be here in New York and excited to discuss more about MiniScript.

SPEAKER_02: The mini-script, what is that even?

SPEAKER_00: actually. Miniscript is bitcoin script, a subset of bitcoin script. So to understand what miniscript is I'll just go briefly into the problems with current bitcoin script. As the listeners of this podcast are aware we have bitcoin script which is a stack based language which operates on certain opcodes which manipulate the stack in certain ways to hopefully finally give you a success result. And even though it seems simple at first glance like you have the stacks and you have these opcodes which do some deterministic things on stack it should be easy to analyze these things but you could do lots of complex things with bitcoin with the current bitcoin script which aren't easily analyzable like look at the first element look at its size and based on that do something else. And what we our goal with miniscript was to have something which is more structured it should enable composition and analysis of script. We also get some other cool features which we will get into but first we get this semantic analysis of script. I give you some script and you want to figure out what it does. It's a miniscript you will you can easily figure out what it is doing and right now if you look stare at bunch of like bitcoin script with this opcodes and weird hexes looking at you you really have no idea and you hope that it does what it does correctly.

SPEAKER_02: Okay, let me try to extract all the things you said here. MiniScript is a subset of the whole Bitcoin script language, and you're only using opcodes to understand what they're doing on a Bitcoin script.

SPEAKER_00: It's best if we not think in terms of opcodes, but we think in terms of fragments or the operations which we are interested in. So Miniscrypt has three fundamental Bitcoin fragments that we are interested in, like signature checking, hash locks, and time locks. And we have different types of hash locks and time locks, but at a higher level we have these three constraints which we would want to use Bitcoin script for, and any combination of those. You could have ANDs of time locks, or like this time and this key, or these three keys spent together. So any combination ANDs or thresholds of these is a Miniscrypt. So we don't have to think in terms of opcodes or what is like check sequence verify or like doing hash or checking the pre-image is equal or not. For thinking about Miniscrypt, it's best if you think about these three basic constraints and combinations of these constraints.

SPEAKER_02: Thanks for watching! So Minuscript is an abstraction layer over Bitcoinscript. It takes the concepts out of Bitcoinscript and expresses them as a logic composition, basically.

SPEAKER_00: Yes, it's abstraction, but it's one-to-one mapping like you can go from Bitcoin script to mini script and mini script to Bitcoin script like vice versa cool, so abstraction people usually think of it like you lose some information or you In a way, but it helps you look at the same subset of Bitcoin script in a more structured way So there is a one-to-one mapping between

SPEAKER_01: Mm-hmm.

SPEAKER_02: Okay, that's important, yes. How did you come up with needing MiniScript? Why do we need it and who is it for?

SPEAKER_00: Okay, so this is before my involvement in Miniscript. How did people come up with Miniscript? It started with PSBTs. So with PSBTs, you have, in the PSBT workflow, we have these different roles where...

SPEAKER_02: PSBT, of course, stands for partially signed Bitcoin transactions and describes a protocol for creating multi-user transactions.

SPEAKER_00: yeah so with this psbt we have like this partially signed bitcoin transactions we have all these different uh rules we have a in a psbt workflow we have say a creator role which creates a basic transaction skeleton and we i'm ignoring the psbt v2 parts for now but let's just stick with the original psbt the rules are pretty much the same we have a transaction creator we have some a transaction updater role which would update the transaction with some necessary signing information we have the signers which could be your hardware wallets which would sign that transaction and we have this role finally called finalizer which is different from signer and the job of finalizer so the job of signer is to get um like take this psbt this bunch of key value pairs and uh for a particular input put its signature in some certain in a key value pair onto this psbt data structure and you would pass on this psbt to different hardware wallets software wallets and we even have extended psbt spec with hash like hash free images and people would feed in all this information into your psbt key value store and you still somehow have to create this script sig or witness and the job of this finalizer uh is to create this like look at all this information which has already used like has all the signatures and everything and finally create this final witness or final script sig fields which those are called in psbt.

SPEAKER_02: Right. So how does Miniscript edit this?

SPEAKER_00: Yeah, this is where MiniScript comes into play. So let's say you have some script. Now you have some complex script, like a three of five. And one of them, you're trying to spend a three of five output. And one of the three of five is, say, another some complex policy which has you implement a time lock, and maybe it can also be spent by some lightning HDLCs. So your hardware wallet just gives you a signature for the corresponding input and the signature message. And now you have to still satisfy this. Given all the signatures, you still have to create a final witness. Now this is where MiniScript comes in. It looks at all these possible, like, it looks at the script which you're spending, the witness script or the redeem script, and figures out what, like, based on this public key, this satisfaction, I have satisfaction for these keys. I know the pre-image is for these time locks. And currently, it is this sequence number for this transaction, and it is this time lock. So can I use this path? It will figure out all, it will take all this information and create this final witness or final script. So it's kind of like a smart finalizer. You could have any MiniScript, and your wallet's just given their signatures and hashed images, and the MiniScript finalizer would just automatically fill in the witness for you.

SPEAKER_02: So the mini script in PSPT is basically used as a recipe on how to Reconstruct all the ingredients all the signatures that people have provided Given the public key information and so forth into the actual Bitcoin transaction that then can be sent to the net

SPEAKER_00: Yes, exactly, and that's how it was motivated. Now you have all these signatures, now how do you actually create this? Right, okay. And that is what led to, like, then we should have, so you cannot obviously do this for all scripts, like you could have complex scripts where you cannot, even if you have signatures or something, you just can't reason about these scripts, how to satisfy those. But then I think Peter and Andrew, where primary and Andrew was trying, Peter, they were involved before I started working on this project, and they decided, okay, if we look at a subset of this, which is analyzable, we can satisfy those scripts generically. And that is where Miniscript was, and that's how Miniscript was started.

SPEAKER_01: Thanks for watching!

SPEAKER_02: Okay, so basically it was, that just describes how we got a subset of script in the first place. We only took the ones that we could analyze and could generically express, and the motivation was to be able to craft these recipes for our PSPT. I think that's also related to output descriptors, right?

SPEAKER_00: so yeah this is also related to output descriptors so output descriptors essentially are like encodings of your witness script or script upkeep or studies reading script so when I say I just try to distinguish those witness script is like SegWit thing and we're doing script is like the P2SH version of ideally we would want to extend these output descriptors with mini script descriptors so you would have right now our descriptors are like fairly like limited you have like multi and like multi is I think probably the most complex one which we have so you mean object multisig yeah no multi descriptor like multi descriptor so with mini script we would have a mini script descriptor which would be something like a WSH of inside of that you would actually write your mini script descriptor and since there is a one-to-one so this is how it like fits in with PSBTs where you have this radium script or witness script and from this I mentioned previously that we have this one-to-one mapping between all of these mini scripts and the scripts so you look at all these witness script you create a mini script from it so one to one mapping we can do that and by looking at that and like the structured mini script and the witnesses you can like create this

SPEAKER_01: That's right.

SPEAKER_02: on the one hand mini script can be used by somebody that looks at Bitcoin script to Convert it to something more generic and the mini script representation and then to forward it to The others so I think you lost me a little bit. Sorry

SPEAKER_00: So I think the question was like output descriptors and how do like how does mini script fit into like I'm interpreting the question as how does mini script relate to output descriptors and like where does mini script fit in this descriptor work so this would be a mini script descriptors would be like an extension to the current descriptors where right now we have like say WSH of multi is a descriptor inside of that you would have WSH and a mini script string representation which would describe a mini script output right okay and that is how like you and then you get all the cool properties of like descriptors you can figure out the script of keys and with mini script you get like figure out

SPEAKER_01: Mm-hmm.

SPEAKER_02: So currently output descriptors do not use miniscrypt yet, but it would be cool to do so. Yes. Okay.

SPEAKER_01: Yeah.

SPEAKER_00: Thanks for watching! yes uh okay yeah it would be like as in output descriptors we use those as in like in russian script and like there is a full like mini script is fully specified and we have we have a good idea and we know that we are going to use how we are going to use output descriptors but they are not specified in bitcoin core output descriptors dot mt whatever it is yeah okay so we have a very good idea and probably a final idea of how many script descriptors are going to look like

SPEAKER_02: Right. . Cool. You mentioned that there is a difference, of course, between, or that there is more than one implementation of Miniscript. There's Rust Miniscript, I think you've been working a lot on that, and there's another Miniscript implementation, is that in Bitcoin Core?

SPEAKER_01: Yeah.

SPEAKER_00: Thanks for watching! I mean that's a C++ implementation which is designed to be implement like easy to be merged with bitcoin core so it's not in bitcoin core it's a separate repository you can go to like zip pass slash mini script and that's a that's a C++ implementation of mini script

SPEAKER_02: Uh-huh. I see, I see. So MiniScript is not in Bitcoin Core at all yet.

SPEAKER_00: No, it is not in vitcoin core at all yet

SPEAKER_02: Uh-huh. So.

SPEAKER_00: How's that gonna happen? Hopefully through some part through me and yeah, community review. So it is one of the things which I have taken up on myself and like hopefully plan to do in the near future is to take Peter's work, like Peter's currently implemented version of Miniscript and make a PR to core to do have Miniscript descriptors and output wallet support for Miniscript. Okay, cool. Yeah, and that will bring bunch of cool things.

SPEAKER_01: Yeah. Thanks for watching!

SPEAKER_02: My understanding is that you and Repolstra, SIPA of course, have been looking at Minuscript for a while. You mentioned that you use it as a tool for analysis of what script does. Can you tell us a little bit about cool improvements that you found or astonishing discoveries you made while doing that?

SPEAKER_00: Yeah, I'll split this into like to answer into two parts. So first is like the analysis part, which is given a mini script, you can look at the mini script, like you can just it's a tree structure, you can look at the mini script, and you can understand what it does, which is something you cannot do with script, you can see it. Yes, I can attest to that. Yes, but not only that it is a since we have this structured format, you can answer questions like, can this mini script ever be spent if I don't have access to my cold wallet? Can anyone ever spend the script and you can answer these type of questions which you might want for your security order?

SPEAKER_02: Yes, I can attest to that. You Yes. That sounds really important in the context of PSBT and some of the vulnerabilities we found with hardware wallets in the last year or so where hardware wallets could be tricked into participating in transactions where the outputs were actually not spendable by them and things like that.

SPEAKER_00: So this allows you, this is more for your software wallet, analysis type of things, but hardware wallet, like it does not help you. Hardware wallet probably do not even need to understand mini-script, which is slightly digressing, but I think I should highlight this point. So mini-script, like hardware wallets should just understand that given this, this is your key and this is the PSVD, just create a signature for it. And in the PSVD workflow, they don't need to understand anything. They just need to know, I know this private key and I'm asked to give the signature. I'll give the signature. Now mini-script does not deal with like vulnerabilities of those sort, but your software wallet on the other hand can make these claims that if I trust this hardware wallet or if I trust this key, and as long as that is not hacked, I have all these different components of my script or spending different spending parts, as long as those are compromised or whatever happened with them, I can be sure that I have this thing with me. And without that, you cannot steal it.

SPEAKER_02: So being able to more clearly analyze how the script works allows us to test our security assumptions.

SPEAKER_00: Yes, so when I'll correct myself slightly I've mentioned software wallet I should just mention software like it does not have to be wallet Like you could have a mini script analyzer Which will like analyze your script and tell you statically like this cannot be spent before this time and this cannot be And you do this generically

SPEAKER_02: Yeah, we've had lately a bit of a push by some people to distinguish wallets from signers. Like actually a hardware wallet might be better called just a hardware signing tool or module because a lot of what we think of as the wallet is really the software that keeps track of the funds and provides UX to the user, right? So maybe that's a little related here. The hardware signer and the software wallet, right? Yeah, the software wallet, yeah, the software wallet, yeah.

SPEAKER_00: Yeah

SPEAKER_01: Again.

SPEAKER_00: The software analyzer, it does not even have to keep track of your funds or anything. It's just for analyzing your script and so that is the analysis, like that's how mini script relate to semantic analysis and you can, if you are open for more PRs or anything, if you find more cool things to analyze with this and for example, like I just have access to these mini keys, how does my script look like? I never want to use my cold wallet, what are my spend, what do my spend conditions look like? I want to spend it two years from future and you can answer these type of questions. So going to the other part, which is like while analyzing these things and while working on mini scripts, we discovered like bunch of interesting things or limitations of scripts. As long as you, whenever you try to do something slightly complicated, you run into the script resource limits, which are like the 201 opcode limit, some standardness and policy, so standardness and consensus rules about the script, like about the script size, rules about how many witness elements you can have initially in your stack as a standardness rule. Yeah, I think those are like, those are the important ones. So if you try to write complexive, you just run into a case where you are certainly exceeding 201 opcodes. Is that per transaction or per input? That is per script, per output, sorry, per input, which you are executing, previous output. But if I give you a, let's say you are trying to, so mini script has to deal with all of these things because if I am spending, if I give you a mini script and you look at it, you look at the tree and you say, oh, it looks great, like I can spend it with this key and you analyze your own policy, maybe for your company, you implement some complex policy. And let's say there's one path which requires like more than 201 opcodes to spend it. So mini script has to like detect all of these things and one or just like not have those as valid mini scripts where you say that user, maybe you're, if you try to spend this funds, the network won't accept it.

SPEAKER_02: Right, so you could have a very complex script where parts of it are actually unspendable due to the complexity that it takes to create the input script for them. That would be a pretty rude thing to do to a transaction partner.

SPEAKER_00: I'm Thanks for watching! yeah and if you're in a multi-party setting maybe you just trick them you're saying like oh this part looks good yeah why don't you accept it and then you know then they try to spend it and boom you cannot spend it

SPEAKER_02: Oh, do you want to give me 50% of your money in order to spend your money? Yeah, I see where that might be going.

SPEAKER_01: Yeah.

SPEAKER_00: Yeah, I don't know. Yeah. So that is one. So you could also, for example, have like your script size, like some, maybe some of your satisfactions require more than a hundred elements, then certainly it becomes non-standard. So when you script, when we tried to look at, when you looked at these things, we hadn't like thought, okay, this is a problem because when you're dealing with small scripts, everything is good. But when you are like certainly touching these resource limitations, you exceed one of these paths. And then some mini-script detects all of those things in like, in SegWit context, you have these different rules. So mini-script would tell you, it would warn you that this script has spent paths, which would possibly...

SPEAKER_01: Thanks for watching!

SPEAKER_00: and which cannot be spent. One of the examples is like Russell O'Connor recently discovered that, it was known to people but recently highlighted that you cannot spend a time lock and a height lock in the same thing because your number for n lock time in a transaction, it is either greater than five million, in which case it is interpreted as a timestamp or it is less than five million where it is interpreted as a block height. And say you were given this thing where your satisfaction suddenly requires you to have a time lock and a height lock and you just cannot do both of them together. Right, obviously. So we run into these issues and the job for MySQL is to do this once and for all, like check and the library would warn the users that okay, you are participating in a transaction where like you should not be participating in this transaction in this contract with someone else because it has unspendable paths.

SPEAKER_02: Thanks for watching! That sounds really hard to delimit, like this small section of possible scripts that are actually spendable, well-formed, don't exceed any limits, are standard, and not malleable. Yeah, so that's what you guys did, right?

SPEAKER_00: Yeah, so that's all. And not malleable like I There was an important part, which I should have mentioned the start Yeah, many scripts are designed to be non malleable like with segregated witness or segwit We destroy one form of malleability, but we also have other forms of malleability we have as in like your poorly constructed contracts could have could be malleable in other ways and We design if many script policy like library says that this is safe. You know that if you're satisfied using that It would be like it would be safe non malleable Where this comes into play is you could for example Have a weird contract and change your witness such that it is still satisfied the funds are still sent but you increase the size of transaction and That sort of vectors would like decrease that's that is an attack vector because it decreases the fee By the bite of the transaction and suddenly it's not confirmed and then you have this right? You could talk

SPEAKER_01: Thanks for watching!

SPEAKER_02: Maybe make a pinning transaction pinning attack that way or or just delay the confirmation of your trends. Yeah, and that

SPEAKER_00: Yeah, and that affects security of off-chain protocols because that's certainly a security assumption for them. And so it is important to have these things and that you know that these things are non-malleable and having assets.

SPEAKER_02: So we covered a little ground here. We found that mini script is always not malleable, that it is a smaller subset of all of script's expressiveness, which in some allows you to make more final analysis of whether you can actually spend what you're participating in and things like that. But my understanding is that you have a converter that takes a script and produces mini script, and then vice versa, you can map it back. When you fed in some of the scripts that are currently used on the network, say in Lightning, what did you find out about them?

SPEAKER_01: Hmm?

SPEAKER_00: Yeah, so a mini script, as we said, is a subset of script. So current lightning script, first off, is not a mini script, unfortunately, because it does weird things where it looks at the first element, sees its size, and determines whether that's a public key or a preimage. And that is something which is not friendly to the mini script, like the type system. So with mini script, we have this additional tool, which we call the policy, mini script policy, that is designed as a way for developers to approach mini script. Because if we look at mini script, it has ands and ors of these things. But we also have this wrappers around those things, which manipulate each fragment. Wrapping means wrappers mean when you transform mini script from one type to some other type. Or you change some of the type properties. Each fragment does something. It either puts something on top of stack, or puts nothing on top of stack, or evaluates the second expression. So mini script has these two, broadly speaking, two attributes. One of them are correctness attributes, and one of them are non-malleability attributes. And these correctness attributes show how we want to combine or compose this mini script. So mini script also did not highlight this. It's also composable, which is you have a mini script with which outputs, which is for certain set, and we have another mini script. And you can compose using this with ands and ors and so on. But you cannot just naively compose them. We have different ways of composing things. And just directly composing them does not work at mini script level. So when we modify each fragment, we change the type of each fragment. We call those as wrappers. Wrappers are transformation from one type to other type. So we go from the simplest example. If we have something which pushes a non-zero element onto the stack, which is we call it type B on mini script, and we add a verify wrapper. So if we just put up verify after it, then it would just put nothing on stack. So it's a transformation from mini script type B, which puts something on stack, to a verify wrapper which just checks. If it aborts, if the top is not zero, and it will not push anything on stack. So we have all these different mini script types which hold these different invariants across. So this is bit into a technical design. But these are the mini script wrappers. So why I was getting into those is these wrappers are required to make the mini script composition work. You cannot just write and pk and pkb. You would have to write something like and pk and w. If you read the mini script documentation, you would understand what all these wrappers do. But they essentially help in composing these mini script fragments. Thanks.

SPEAKER_01: Mhm.

SPEAKER_02: So basically you're saying that there is not just an AND operator, but there's different operators depending on which types you want to combine.

SPEAKER_00: yes there's different operators and you can also change what types you want to combine using these different things so that is somewhat like tricky to understand at first so we have this thing called manuscript policy which is another abstraction layer out of manuscript where you remove all these wrappers where you remove all the different types of ands and ors and you just have simple like the one which you want to look at and of this does this and all of this which is what you would conceptually visualize your manuscript as and

SPEAKER_01: Thanks for watching!

SPEAKER_02: So that's basically a human readable, writable thing that then later gets transformed into a mini-script and from the mini-script is of course exchangeable to bitcoin script.

SPEAKER_00: Yes. So I would like to highlight that this is a one, like this, this policy. Yeah. This representation is what we call the policy. And we have a one way for going from mini-script policy, which we call compiling. So it's not a one-to-one mapping anymore because you're losing information when you try to lift up and when you, and so this invariant is, it's not necessary that it will hold, you can go to policy, do mini-script and mini-script to policy. It might not, the compiler might do different things and it might change things, but policy is like the most natural way for any, like developer person who is interacting with script to write something, you think about things that were like, and of this or of this, you don't necessarily think about, you never think about mini-script fragments. Those are like our constructions. So we have, so for lightning policies, we looked at, like we made a compiler, which just looks at all the different possibilities and proof forces things. And we found something which was better in average satisfaction cost than what the, yeah, than what the lightning developers had initially, yeah, had initially constructed and not only that, we get something which has less satisfaction rates for HTLCs. Now this is technically, I like to highlight this, these are never meant to be broadcasted on chain. Like HTLCs should never be, but still they can be in case a sphere goes offline.

SPEAKER_02: Thanks for watching! But still it's true, they can be. You want to avoid it, but they're totally meant to be broadcast. Yeah, they're totally meant to be. Yeah, that's a good point. They're basically cached on the second layer and only when necessary are executed on chain to decide a conflict.

SPEAKER_00: Yeah, that's a good point. yes so we found something which is cheaper to that but not only that that is mini script so with that you get all these bunch of cool things which were discovered like you could have rest mini script like oh any wallet which can satisfy it you could have you could do analysis on it you could do smart fee estimation on it

SPEAKER_02: And you could basically have a lightning signer, use any existing hardware signer as a lightning signer then, right?

SPEAKER_00: you could you could use any signer you would just need a mini script finalizer to finalize all these things so yeah you could use any hardware signer or any signer which you want and you don't need to have all these like hard coded logic for i i've not looked at lightning code but i would assume that they have this a logic which would be like hard coded for this particular lightning script we need to feed in like the first element should be this the second element should be this and third and if you looked at any all the smart contracts which people have deployed they have this hard coded things and this really screws up inter-operation between wallets which is a very slick a good point where if you have many script compatible wallets you have green two of three and something like you cannot just go to some other wallet right

SPEAKER_02: So basically that brings us back to the question, who is Minuscript 4? And it is, it could be used by wallet developers to ensure interoperability with hardware wallets or second layer protocols.

SPEAKER_00: yeah second any any wallets basically like if you're supporting many script scripts and other wallets support many script scripts then you can like they can satisfy your thing you can satisfy their thing it is just the finalizer which i would like to highlight your signer does not need to do anything like it's just only the finalize the part the one which puts in the witnesses into place that one needs to understand many scripts it can just be a software thing nice so you don't have to go to all the hardware wallets to see add many scripts

SPEAKER_02: Nice. You found a way to better express the currently prevalent Lightning transaction types, and how did that go? Did everybody adopt that already?

SPEAKER_00: No, no, I mean my understanding is that in Lightning implementations you already have that deployed everywhere and to change the way in which you negotiate HDLCs and it's not only like just a script problem but a network layer problem probably requires much more of an engineering effort to get it through and I think there like with the new implementations they were discussing it on the mailing list thread about whether they can adopt MiniScript, like MiniScript support it on MiniScript, descriptors on MiniScript scripts and that would be really great if they adopt it and so it's who should use MiniScript if you are a wallet like if you're a wallet you should make sure that you're not doing most of the things can be done by MiniScript it's like hash locks, time locks and signatures and that is most what you use Bitcoin for so you should have, you should have MiniScript and for users if you're doing any complex multi-party contract you can just analyze your thing that you're participating is correct and

SPEAKER_02: So would it be fair to say that MiniScript makes the job of a wallet developer easier?

SPEAKER_00: yeah it allows you more functionality which like you could just be a simple thing like i only support fee2pukki and just have this one thing but if you want to step any anywhere more than that you yeah this would make your life much easier like you don't have to deal with fee like as in like you don't currently yeah you cannot estimate your with if you have any complex contract it is hard for you to know what is the maximum possible satisfaction witness size which you can have maybe you look at this and it's a complex contract you don't know how much fees it how many vbikes it would take you cannot guess its fees so you still have to have the fee output

SPEAKER_02: All right. So when you build a transaction and it is a complex contract that has multiple ways of being executed, Minuscript allows you to directly calculate how big the transaction might end up being on the chain, which you need to know in order to estimate the fees in advance. Yes. And you need to pick the fees while building the transaction before signing. Yes.

SPEAKER_00: Yes, exactly. yes yeah that's one of them as a one small thing which we did not highlight is all these script limitations which we discussed they made that way into tap script so although we did a bunch of work for many script trying to deal with all these resource things but in whip 342 we realized that it's like not a these things are satoshi age things which we like many other things don't know the reason why as in they were there for a denial of service reasons but now we better understand bitcoin so we have removed those limits and those are only like block level limits now also the complex check multi sig of code which did like weird counting for 201 of codes that has also been replaced by a much more thing which we actually check sig add friends which would more represent the cost that actually the cpo incurs when trying to validate the transactions

SPEAKER_02: So Taproot removes ObjectMultiSigAd instead, and a few other of the script limitations have been thrown out in order to make scripts easier to analyze, and all of that came out of you and your colleagues' mini-script research. Yeah. Cool. What's the coolest thing in mini-script altogether, what do you say?

SPEAKER_01: Hm.

SPEAKER_00: Yeah. so i would say like the coolest thing is like this generic signing or generic finalizing where you have your wallet everyone has their own wallet in a fancy future we have these different policies that everyone has you have your own policy you are engaging in a multi-party contract with me i have my own policy you have your hardware wallet somewhere else i have my signer somewhere else and in a psbt workflow we would just transfer this psbt around all the wallets would just put in their signatures at their respective places and we have this complex contract the wallets don't even need to know where what the contract is like where is the three of five or something they just need to know i give you this public key this is the message you need to sign for they would put the signature there and mini script would just end you just have one final mini script software which would create this thing and this is really cool because previously you have all this like there's no inter-operation between wallets now you have different wallets which do not even need to understand mini script and with this like just a final piece together you can you

SPEAKER_02: So this, this will make it a lot easier for various different wallet software to interact and basically establish a industry standard on how to think about scripts.

SPEAKER_00: Yeah, mini script is a standard like you would it is bitcoin script, but it is one of the so it's not necessary that you have to You don't need any software or any like any other consensus implementation You just have mini script, and you just need one final software, and that's it

SPEAKER_02: What's the general status of Minuscript? We talked a little bit earlier about how you're still working on getting it implemented in Bitcoin Core, how there's prototypes for it, but where are we at with Minuscript right now?

SPEAKER_00: We have, my primary role has been on the Rust implementation, like the Rust mini script side of things. And one of my projects there is to extend the mini script to tap script, like tap root mini script. Now that we don't have all these complex, like these weird constraints, some things become easy. But now we have these new opcodes, so we need new terminals for expressing the checksig out front multi and we also have a different, this is still an R&D, so one side is R&D for tap script, where we have different tap leaf versions and merkle, we are not sure yet, we are still thinking about how to extend that to tap root, which will make things easy. And on the other side where we have segwit and support for that. So the Rust mini script version is almost finalized, we are going to add new features which would be more like how do you analyze things, but the base level mini script design and specification is fixed, like there is nothing to be changed over there. And you might add more smarter compilations, but for the C++ side of things I am, I will be working, as you say I am working, so it's more correct as like I am working for the past few days. I will be working towards getting Peter's, his repository mini script updated with Rust mini script and getting some to be over there and then transferring and that would be like a multi step thing because we will discuss more with the community how that goes because it has a bunch of features as we discussed, one of them is just like script to mini script. Then we will have like, I don't know if analyzing capabilities belong in bitcoin core or you want different software for it, we definitely want support for generic finalizing, that would be another task and all the tests and test framework and all those things, so let's go.

SPEAKER_02: And then, of course, it has to map one-to-one to each other and behave exactly the same way between the different implementations. So probably it has a very strong testing core set, which I'm under.

SPEAKER_00: Yes, we have tested like, I don't know a million, but we have tested a lot like all the different possible combinations of MiniScript. Peter has one more cool tool called Gramtropy, it's not one of his popularly known projects, if you give it some grammar rules, it would generate the different possible combinations for those and we have tested that extensively with MiniScript.

SPEAKER_02: Is that how you found the better lightning constructions?

SPEAKER_00: So the better lighting construction is a compiler part. So that is when you go from a policy, which you expect to do the mini-script. And this is where people get confused. And I would like to highlight is one of the most common confusions in mini-script across developers is policy to mini-script is not stable. It is something which is just designed for you to approach mini-script. You should just use policy once, get your mini-script and use that mini-script. So the C++ version would give possibly different outputs. The rest of the mini-script would give possibly different outputs. In future, you might have new ways to compile things to mini-script. You might rearrange things. So just as policy is just one way to approach mini-script, you should not treat policy as your mini-script. Those are different things.

SPEAKER_01: Thanks for watching!

SPEAKER_02: So the actual interchangeable part is the mini script, mini script policy is the human writeable part that once gets compiled to mini script and then you should stay there. Yeah. Cool. So the next step is to make Bitcoin Core or the Bitcoin Core compatible implementation plainized with REST mini script and then hopefully to roll it out. And my understanding is that the TypeScript functionality is in REST mini script already? Yeah.

SPEAKER_00: No, it is. So, Tabscript functionality is in, like, it's in works. Like, we're still in Rn, like, there's no code yet we are discussing. Because there are a bunch of things which we can do now in, with Taproot. Like, you could have a private test. Let's say you have to, like, one of the benefits of Taproot is you don't have, you only show what you're executing. If you have an OR of two things, you don't show what your second OR is. And so, then we can, like, that have as a different hidden node and just show the script which you're executing, which is not true for SegWit. So, there is still some, like, design things to be done over there. We still have a good idea of how we want to do it. There's one way where you go, like, completely private, where, let's say, you have your leaves, all of the leaves just represent ORs of different things and you only show one of them. And there's a trade-off, like, maybe that blows up too high. Let's say you're doing 11 of 15 multisig or something, then you clearly cannot have all the different ORs in the leaf, that would be too much. So, there is still some trade-offs and design to be figured out there, but that's...

SPEAKER_02: So you would want to, for example, make your Minuscript compiler take into account how many leaves that would require to express a construction like that?

SPEAKER_00: Yeah. So yeah, TapScript compiler is still in work, but the TapScript to MiniScript, that thing should still just, that is almost online. You just have new fragments for checks, multi-sig, and we remove the resource limit checks and so on. So that is rest MiniScript. That's not, as far as I understand, like Bitcoin Core Wallet support for Taproot is still like right now under review. So I think we'll just go slowly over there with SegWit and test framework and just make developers familiar in general with MiniScript, make them comfortable. So we have more informed review and go forward with that. Okay.

SPEAKER_02: Yeah. That sounds all really cool. Are we still missing something? Did I forget to ask you something?

SPEAKER_00: I think that mini-script covers pretty much it. Mini-script is just part of descriptors, like at a high level to summarize everything. Mini-script is part of descriptors which fit into all of this PSPT workflow. And mini-script would help you compose scripts, analyze them, find smart fees, generically sign for them. Right.

SPEAKER_02: Right. How do we keep abreast of the updates regarding mini-

SPEAKER_00: There is a pound pound mini script IRC channel, which is fairly active. So we discussed a lot of things over there and rest manuscript and simple as my script are the two repositories and if you want to play around with mini script Peter has this great website, which is like a go-to resource for my script, which is bitcoin dot cpr dot be slash mini script So that is the place where you can start and if you are if you have any questions approach at pound pound mini script

SPEAKER_02: Those will, of course, be in show notes, then. I hope you liked that. We're going to probably record a few more episodes soon, because more people are going to be in the office again. And we might be going to more conferences as well.

SPEAKER_01: Chain code podcast is back again full force We've said this before but this time is different. We we mean it All right Thanks, Merch. Thanks for putting that together. They'll be show notes and we'll see you next time. Yeah. See ya

