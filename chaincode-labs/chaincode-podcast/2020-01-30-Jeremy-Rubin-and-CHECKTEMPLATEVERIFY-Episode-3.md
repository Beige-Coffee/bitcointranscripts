---
title: Jeremy Rubin and CHECKTEMPLATEVERIFY - Episode 3
transcript_by: Whisper AI & PyAnnote
categories: ['podcast']
tag: []
---

Chaincode Labs podcast: Jeremy Rubin and CHECKTEMPLATEVERIFY - Episode 3

SPEAKER_00: liquidity crunch in the Lightning Network. We need to create a thousand new channels. Now it's a single UTXO to create those thousand channels, and then you can kind of redeem them over time when they're actually needed to be pulled out, but now you've added this sort of like spot fix. And you can also add routing in between the channels internally in this tree.

SPEAKER_02: Hey folks, this is the change-

SPEAKER_01: podcast. So you're going to be talking to Jeremy Rubin about op-check-template-verify.

SPEAKER_02: Yeah, this is a proposal to add Covenant-like abilities to Bitcoin script. It's going to be a great talk. Enjoy the show.

SPEAKER_01: Welcome to the podcast, Sherbet.

SPEAKER_00: Yeah, thanks for having me on.

SPEAKER_01: So I think to start us off, tell us a little bit about sort of your background and how you got into Bitcoin and we'll take it from there.

SPEAKER_00: Yeah, I first heard about Bitcoin in 2011. I was interning at MIT during high school, and I was doing what interns do, which is read hacker news. And I saw an article about Bitcoin, and I thought it was pretty cool. And I remember asking some other people in the lab, like, what do you think about this? And people were like, Bitcoin is stupid, like, okay, well, it's kind of interesting. Later that fall, I went into my senior year of high school, and I started seeing more stuff about Bitcoin. I knew some people who are buying some things online with Bitcoin, and I was like, this is interesting. So I booted up a laptop, like a second laptop, and I turned on, I think, CG Miner or something like that, and started mining a little bit of Bitcoin. And then I was like, wait a minute, I'm trying to sleep, and this fan is really loud. So I turned that off and kind of ignored Bitcoin, but watched. I was like, hmm, should I buy some on Mt. Gox? And I was like, hmm, I don't want to link my bank account to this sketchy Japanese website, which, you know.

SPEAKER_01: ended up working out all right.

SPEAKER_00: it ended up working out alright. I kept an eye on it for a few years and then fast forward to the summer of 2013, I'd finished my freshman year of college and I started getting more interested in Bitcoin. I bought a little bit on Mt. Gox that I eventually lost and started thinking, you know what, this is actually really cool. In the fall of 2013, I decided to start doing some projects. I learned a little bit more, I was a bit of a better programmer, so I started a project called Tidbit, which was a way to replace advertising on websites with cryptocurrency mining. It was kind of a neat project, we had the messaging kind of drilled down where it's about fixing the internet, bringing it back to the people, getting rid of these evil ads that are bad for democracy, bad for journalism, we were a little bit ahead of our time. Then we received a really nasty subpoena from the state of New Jersey, which basically was not exactly them suing us for making any charges, but they copy pasted language out of their version of the Computer Fraud and Abuse Act. It was basically all these felony statutes where it's like, did you do da-da-da-da-da? That's a thing that is a felony and has a mandatory sentencing and things like that. We were pretty freaked. We got the support of some various legal nonprofits like the Electronic Frontier Foundation. I think that that was a big crossroads for me where it's like, okay, this Bitcoin stuff, it's cool, but is it going to be a big problem to work on? Then that's the point where I decided, okay, I'm going to double down and stick to Bitcoin. From there, did a number of projects at MIT, including the Bitcoin AirDrop with some of the other chain code guys. They helped out there too, to give every undergrad $100 of Bitcoin. We gave in 2014 like 4,000 undergrads, 100 bucks of Bitcoin, and just looked to see what happened. Then I started the MIT Digital Currency Initiative, the MIT Bitcoin Expo. Then when I was graduating, I was deciding what I wanted to do and figured, okay, well, I've been doing a lot of Bitcoin related stuff and research and community organizing, but I think now that I'm out of classes and stuff, I have time to actually do more full time open source contribution. That's been since 2016, what I've been doing.

SPEAKER_01: Very good. And, uh, what's CTV?

SPEAKER_00: Yeah. So CTV stands for Check Template Verify. It is previously gone by other names. You may have heard of it on some other, you know... What are those other names? I used to call it originally CoshV, which stood for Check Outputs Hash Verify. But I realized that there were some bugs in that implementation, and you needed to hash more than just the outputs, and so I changed the name. And then I called it Secure the Bag, pending having a more sane name. But I kind of like the name for various metaphorical reasons, but not everyone shared that. So eventually to do whatever it takes to get people to adopt it, it's now called Check Template Verify, which people are relatively happy with.

SPEAKER_01: What are those other names?

SPEAKER_02: OK, and from a high level, what is CTV doing?

SPEAKER_00: Yeah, so CTV is a way of enabling a really rudimentary form of covenants in Bitcoin.

SPEAKER_02: Okay, what's the covenant?

SPEAKER_00: Covenant is a way of restricting the way that you can spend a coin. This sounds like a little bit of a weird property and something that maybe already exists in Bitcoin. If I spend to a specific key, haven't I fundamentally restricted to somebody who knows that key? And you have. With CTV, what you're doing is you're not just restricting to somebody who has that key. Once somebody has that key, you're restricting what they can do with it, which is a little bit of a departure. We have some precedent for this in Bitcoin. If you have a check sequence verify or check lock time verify opcode, you're saying to somebody I'm giving this coin, but you can only spend it after a certain amount of time. So we've restricted what actions they can take. Check template verify is even more restrictive. You're saying to somebody that this coin can only be spent in this specific transaction. You've restricted it to a specific transaction that can happen. And that itself is a little bit of an odd property because you might think, well, if we're restricting to a specific transaction, why not just do that transaction right away? And it turns out that there's a useful way that you can sort of program at the transaction level if you allow transactions to be played out in this way. And that's sort of at the heart of what CTV is accomplishing is allowing people to program Bitcoin at the transaction level instead of at the script level.

SPEAKER_02: OK, so the concept of covenants has been around for a few years now in Bitcoin. Can you give us a bit of historic context? What have the previous proposals been and how does CTV differ from those?

SPEAKER_00: Yeah, so the discussion of covenants I think originally took place maybe in 2013 on Bitcoin talk in a much more advanced form than what CTV is. At that point, it was what if we allow arbitrary zero-knowledge proofs to determine what the transaction should be and you just satisfy the zero-knowledge proof and then the transaction matches that pattern? What's the worst thing that you could do? And people came up with all sorts of weird ideas of like, oh, well, you could make a function that looks at all of the blockchain state and determines if something has happened before you're allowed to spend. You could, I don't know, restrict that the government's key gets added to all of your coins and that is perpetuated every single time. So you have some sort of recursive nature of these. And people at that point, I think like covenants are maybe a scary thing. They maybe shouldn't get added to Bitcoin. Following that in I want to say 2015-2016, I think 2016, some researchers out of Cornell and a few other institutions I think in one of the Israeli universities put out a paper which was doing a different type of covenant that was just a simple pattern matching based one. So you essentially have a regular expression that would say, does the output of this transaction match what I've specified? And these were relatively powerful. But because they were doing this weird transaction introspection and they enabled recursion, people didn't feel that they were appropriate for Bitcoin. It sort of violated the abstraction layers that they wanted to keep. And so those were not adopted. People also were sort of like worried given the previous 2013 discussion that these were going to enable something fundamentally bad for Bitcoin. And so even though there were some interesting use cases that had been proposed for these covenants in that paper, they didn't see any push to actually get that proposed opcode into Bitcoin. Fast forward maybe in 2017, I give a talk at the Stanford Blockchain Conference kind of saying, let's think about covenants and programming at the transaction level. A lot of people told me that that was like a really good talk, that they really found that that talk explained a lot of things that they hadn't been thinking about before and that they felt like Ethereum is really exciting. You can do all these programming things in Bitcoin. You can just do transactions. Now people were thinking, wait a minute, there's maybe some easy steps that we could take to enable a lot of programmability inside of Bitcoin. But I didn't have a concrete proposal of how we would add those things. And so I spent some time over the next few years thinking, well, what can we do? And I thought about doing pre-signed transactions where you delete the keys, but I was unhappy with that. And so I thought about, well, instead of pre-signed transactions, where you delete keys, what about maybe doing multi-party signatures where you then at least just need one person to delete the key, but then you kind of have this weird online multi-party computation and it gets really messy. So then last year I said, well, what if instead of trying to dance around the issue, I just find the minimal most conservative thing that I can that accomplishes these goals? And so I came up with originally Coshfee, now Check Template Verify, as this thing is really hard to work with. It has a minimal set of features. It can't do all these pie in the sky things that people want. However, with just the small kernel of capability, there's a lot of nuanced things that come out and you can make really, really powerful contracts in Bitcoin without imposing on the ecosystem too much bloat or complexity.

SPEAKER_02: And specifically, CTV wouldn't allow you to make these kind of infectious covenants that run with the transaction and last forever.

SPEAKER_00: Yeah, correct. That was one of the design goals originally of CTV. That's since been slightly relaxed. I had originally made a version of CTV, which provably with other extensions to Bitcoin would also not introduce this behavior. But now if people later felt like they wanted to add some other opcodes that would be maybe purposely trying to introduce recursive covenants, it would also be able to add it. Things like opcat that we kind of know enable all sorts of weird use cases that are unexpectedly complicated.

SPEAKER_02: OK, so that's kind of a high level historic tour of covenants. Why are people interested in covenants? What are some of the use cases that people have been talking about?

SPEAKER_00: Yeah, so there are a number of use cases and I guess maybe now is a good time to plug the website that you can check out. If you go to UTXOs.org, there's a lot of information that, you know, has like nice diagrams so you can kind of get a little bit more intuition. Just hearing about these things, I think, can be a little bit tough to follow. But there are a lot of things that people are excited about. I think being here at ChainCode this week, people are very excited about vaults. A vault is something I think that was potentially proposed earlier, but it was at least discussed heavily inside of this paper that came out in 2016. It's called MES 16. And the idea behind a vault, there are different structures for them, but it's I want to encumber my coin inside of a contract that gives me an opportunity to undo a mistake. So the original one says, what if somebody steals my private key? What do I do? And the idea was that you have a recovery key. And as long as you have the recovery key, you can basically keep playing this transaction, which prevents the attacker from actually stealing your coin. And maybe if you're cycling through keys that are yours, you can eventually get to a key that has been backed up and the attacker doesn't have, which lets you recover your coin. Or you can just, if they stole your master private key seed, you can just keep on moving the coins and waiting another time out and the attacker never can steal your money. And then if you think of what an attacker's incentives are, if your coins are in a vault and they can only ever keep you from spending your money but not get money for themselves, maybe you're less of a juicy target. So that sort of vault is possible with Check Template Verify, but you can also do more nuanced types of vaults that give you other properties. The type that I'm really excited about is something that basically models an annuity. And what you do is you set up a CTV vault that pays out a certain amount of Bitcoin on some interval. So let's say once a week it spends one Bitcoin and then you have to wait another week before you can spend Bitcoin from this vault again. This is really a powerful idea for an exchange where I can say I have some liquidity constraint where I need to be adding Bitcoin to my hot wallet on some scheduled program. But I don't want to have to go to my cold storage every time I want to do that. Instead, if I can estimate what my liquidity needs are, I can set up this vault and I can allow some junior employee to move the funds from the cold storage to the hot storage without worrying that they're going to subvert the whole process. Meanwhile, if you notice that one of these withdrawals has been hacked and somebody's tried to steal your coins, you can prematurely halt the execution of this vault and send all the funds back into your super secure cold storage system. And so this is a pretty exciting idea for Bitcoin because this gives people much more flexibility in how they move their coins around and more security and safety sort of feeling that they're not going to have messed up. So I'm pretty excited about vaults as a potential for that.

SPEAKER_02: Yeah, I think both on institutional level and as an individual Bitcoin user, the idea of having some way of securing your Bitcoin in a way that if your private key gets compromised, you can still claw it back.

SPEAKER_01: How are exchanges doing this now? What's the architecture of a lot of their setups?

SPEAKER_00: So usually for an exchange, and I've never worked at an exchange, so they're a little bit secretive with what their exact setups are, but I think that they typically rely on just plain multi-sig that some key employees have, and that handles the cold storage. So if that's for a lot of money. And then maybe one of those key holders is their attorney's office, things like that. And then they'll have hot wallets that are a reduced amount that more people have access. And then they'll have maybe like a really hot wallet, which is just like a server. And if anybody logged into that server, they can maybe steal a million bucks, but you'd see who logged in and whose key it was, things like that. So they'd be able to trace it, but the money would be gone. I think that's sort of a typical architecture. And that's almost what we're trying to emulate here. At the end of the day, at some point, you want to be able to get an unencumbered coin. You want to be able to say, okay, we've moved the funds back to cold storage. Nobody can touch them except for the set of people. What the goal is with these vaults is to make that operation much less necessary and less frequent. The idea that you need to access these cold keys hopefully would be something that you would only have to do once a year in exceptional circumstances rather than any time you need to add liquidity to your hot wallet. And I think to John's earlier point about this being for both institutions and for individuals, institutions have a lot of money to create these complicated systems that have people and checks and balances, but individuals don't. If I'm an individual and I don't want to trust other third parties setting one of these things up with multisig, it can be quite complicated. Who do I trust to be part of my multisig set? And with CheckTemplateVerify, what's I think rather nice is you don't have to have those other people involved necessarily. You can have these flows and you're the only person who's in control after you've made that decision. And that resonates with sort of one of the Bitcoin branding and marketing phrases early on, which is be your own bank. And I like to think of that not as just like, oh, like hold your own money, but also provide yourself your own financial services. And I think that CTV helps people do that.

SPEAKER_02: Very nice.

SPEAKER_01: that Bitcoin Trust Fund Babies will thank you in the future. That's actually their allowances and you know, things like that.

SPEAKER_00: Yeah, exactly. I think that that's a fun way to think of it too, is that if you are thinking of, how do I leave Bitcoin to my family? Well, we know that maybe Multisig wouldn't be good, because inheritance schemes, you know, people are always arguing about who has the, you know, right to spend. But if you said, look, I think this money would corrupt my family, and I want them to have a reasonable amount of money, but not unlimited, you could set them up on a program to receive, let's say, a Bitcoin a month for the rest of their life, if you had a lot of Bitcoin. And that might be a more robust way of, you know, ensuring some sort of inheritance.

SPEAKER_02: Okay, so moving on to other applications of simple governance and OPC TV, there's something called payment pools. Can you tell us what that is?

SPEAKER_00: Yeah, so the payment pool is in a well-defined specification in the same way that channels are not the Lightning Network. The Lightning Network has 100 bolts, which tell you exactly what you're going to do. Payment pools are a general concept, which is that a group of N people are sharing a single UTXO, and whenever somebody says that they no longer want to share the UTXO, you will create a UTXO for them. Otherwise, you'll rebalance funds among the remaining participants. That's the core idea behind a payment pool, and there are multiple ways of implementing that. Where CTV comes in, in helping design payment pools, is that CTV enables you to create these sort of non-interactively constructed contracts. What that means is right now, if I wanted to create a payment pool, before I do that, I have to get from all participants which coins they want to spend, and I have to get a signature for them for the first state of this payment pool. With CTV, if I'm, say, Coinbase, I can just say, okay, these 100 people have requested a payment. I'm going to group them into a payment pool, and I'm going to send them those funds, and then they're going to know that they have a redemption receipt inside of this payment pool automatically without requiring any signature. So if somebody's offline permanently, and they just request this one withdrawal, you kick them out of the pool, otherwise the remaining people can sign off on a number of update transactions to that pool, hopefully saving total UTXOs.

SPEAKER_02: Yeah, I think that primitive is it very interesting. Any construction where you have multiple people, multiple agents controlling a single UTXO, and they're able to rebalance amongst themselves without changing the UTXO set of the Bitcoin network gives us the opportunity to scale Bitcoin much more massively than we can right now. Lightning Network is maybe the first iteration of that where two parties control a single UTXO, but these payment pools where multiple parties control a single UTXO would allow us to do things like payment channel factories, for example, and have a lot more constructions of how to lift payments off chain.

SPEAKER_00: Yeah, the basic way that I've been thinking that you would actually want to construct payment pools is that you would have a tree of lightning channels. And there are various constructions, you know, people are kind of thinking about what's best. Some people like where it's not actually a tree, it's just sort of you emit one person at a time. But I think what's nice about the tree of channels is that at the lowest layer channels, which are just two party, you know, it's compatible with lightning existing and you can route around the entire network. But also you get sort of a privacy benefit in that right now every update to the payment pool, if it's not a tree, you have to involve everyone and get a signature for everyone. But if you have a tree of channels, then it's just two people have to agree. And when you want to do a higher order transfer between two people who don't have a route or who max out their balances, you percolate up that tree of channels to coordinate and if somebody is offline, then you need to go on chain. And you can kind of I think, if you look at the probabilities of different things, you can prove that this ends up being roughly equivalent, even though it might generate a couple more transactions logarithmic versus linear.

SPEAKER_02: And I think another interesting thing is that OPC-TV seems to me to play quite nicely with Taproot and SIGHASH No Input. Taproot allows you to have this tree of different spending conditions, and each one of those could contain an OPC-TV encumbered output, only one of which would ever be redeemed, and then SIGHASH No Input or Equivalent allows these Layer 2 protocols to act a lot like Layer 1 protocols, that they can be updated sequentially.

SPEAKER_00: Yeah, so in terms of Taproot, there's definitely strong synergies. When I originally imagined this, I said, OK, well, I will just deploy it as a new Taproot script opcode. And then I realized not only was there an uncertain timeline for Taproot, and I wanted to make the changes independent, but also there are strong reasons that you might want to use this in bare script so that you don't necessarily want to do it inside of a Taproot spend. So they became separate things. But originally, there was a strong idea that, yeah, with Taproot, this enables a lot of really cool things. The reason why Taproot enables something fundamentally different than what you can do with CTV already is that Taproot allows you to put as many possible spending conditions as you want and only pay if you know some probabilities of how frequently you're going to use one of these conditions, 0 of 1, for that. So it's no extra overhead, but you get to have a number of transactions now that you're committing to. So you can say we can do either transaction A or transaction B or transaction C, and now you've defined a program that has state transitions that are not just a single transition per thing, but multiple options. And you can do that in script already with if-else branches, but those grow linearly with the number of things you want, rather than with Taproot, where we can do it in 0 of 1.

SPEAKER_02: And you also get a privacy benefit.

SPEAKER_00: There's also a privacy benefit. One of the nice things with Taproot is baked into it is the idea that you have a multi-signature that you can agree to. So if you imagined that you had that payment pool I described earlier where it's a tree of channels and people are routing, and then if people at a higher layer in that tree want to agree to something, they can agree to it. There's already a multi-signature baked in, and so that helps you sign off on the redemption transaction and in the optimistic case, you don't need to go through any of the actual contract resolution. I think that that's a pretty powerful idea, is that I'll know that CTV is really successful if I never see them on chain. If people are not actually using it, it's like, okay, these payment pools work and people are getting enough coordination, but what CTV is fundamentally doing is allowing people to not have to trust and being able to coordinate without coordinating. I think that that's a neat idea. And then with regards to your other question about SIGHASH no input, any PREVOUT, any script type stuff, what's really fascinating is that we actually have a bit of a proof that if you were to enable SIGHASH no input, you would also enable CTV. So you would enable a very similar behavior to what CTV is providing. There are strong reasons that you would actually want those to be separate changes. CTV is more performant and takes up less space and is the correct abstraction for the job. But strictly speaking, there's an equivalence. What that means later on down the line is when people are advocating for an actual implementation of any PREVOUT, any script, which I think is still pending, they're making less of a leap from what Bitcoin is already doing. So it makes this any PREVOUT, any script, which is viewed, I think, by a lot of people as a very non-conservative change, it changes a lot of things that people really care about, that leap is going to be a little bit smaller. So it'll help that go through, I think.

SPEAKER_01: Well, but not obsolete is what you're saying. It's there's there's there are additional benefits to any prev out

SPEAKER_00: Yeah, it doesn't obsolete any prevout. Any prevout can fundamentally helps with updating state in a different way than CTV does. So in these payment pools, you might be using this any prevout, any script, once you've already committed to a CTV internally. That might be the way that you balance it out. And CTV also has greater flexibility that if other opcodes like opcat get introduced to Bitcoin, you can do all sorts of other types of covenants. Whereas with SIG hash no input, you might not be able to do those sort of more fancy covenants. You'd still be restricted to just what CTV can do without opcat. So there's some additional features that could be coming down the pipeline with CTV, but not with just SIG hash no input.

SPEAKER_01: Can you tell us a little bit about how you imagine CTV working with lightning channels?

SPEAKER_00: Yeah, so there is several use cases that I think are pretty compelling for Lightning. The payment pools is kind of the prime, you know, first obvious one is, okay, we're going to create all these channels, and then if we can get people online to agree, we'll update the channels, construction themselves, that's pretty useful. But I think before that gets rolled out, because that's a pretty complicated ecosystem change to support that, you can also just create a tree of channels. And that allows you to only have to redeem the channels that you need to redeem. So it makes channel creation more efficient. People have looked at channel factories, CTV allows you to pretty easily, without having to get people online, like create a bunch of channels for them. So Coinbase could already, you know, when people withdraw, they could pay out into channels and people already have liquidity. The other idea that I like is that when you create these channels, they're not just, you know, like everybody gets one channel, you can actually create a tree of channels that's linked against the existing Lightning networks that you're adding liquidity, like to a large set of like, it's like, okay, we've got this big liquidity crunch in the Lightning network, we need to create 1000 new channels. Now it's a single UTXO to create those 1000 channels, and then you can kind of redeem them over time when they're actually needed to be pulled out. But now you've added this sort of like spot fix. And you can also add routing in between the channels internally in this tree, so that people get a very, you know, liquid network of payment options, which I think is a pretty powerful idea. The other thing that it does for the existing, you know, Lightning specification is that you can replace the HTLC outputs in each transaction with a tree of HTLC output transactions that resolves to some base case. And what this is nice about is that if you only need to pull out like a single HTLC, you no longer have the sort of bandwidth consideration that you had before with creating so many. Now it grows, instead of O of N, it grows log N. And so if you want to increase that number drastically, I think right now it was was previously set to 12 limit. Now there's one bow, which I think increases that limit. But this makes it more efficient for people who need to make really big numbers of HTLCs that they're not as worried about getting, you know, stuck in the mempool, which would be really bad for their channel.

SPEAKER_02: So what that actually means for lightning is within an individual channel, having multiple payments routing through that channel simultaneously. Is that correct?

SPEAKER_00: Yeah, so the number of HTLCs sort of directly corresponds to how routable your channel is. And when you are limited to, let's say, 12, I think that they increase those limits, then there's sort of a fundamental constraint on how much liquidity you can route through it.

SPEAKER_02: because if the payments fail or the channel fails, you need to be able to put that transaction back on chain and each HTLC adds to the size of the transaction.

SPEAKER_00: Yep. And then this reduces how much it's adding to the chain such that you can sort of resolve the HTLCs in priority order. So you can say, I want to resolve the HTLCs in order of which ones have the most money in. And so maybe you can imagine a protocol where the later ones you still want to resolve them, but you want to like lock up the money that is problematic first and then kind of deal with the ones that are less problematic that maybe haven't been recently routed through or something. And so I think that is a lot of these things are things that shouldn't come up. You know, these are only in the non-optimistic case that somebody's like cheated on a route and that can happen, but this makes it easier to know that you're going to get your funds back and less chance of like getting stuck and then somebody snipes your output. And so I think that that overall improves the security while also improving the number of routes. And this will in turn, if you can have more routes, it means that collateralizing a lightning channel is more efficient. So if you have this money locked up, you'll increase the amount of fees that you can collect as a routing node, which means that people have incentive to put more money in. And it also means right now that if people have a lot of HTLCs that they want to create, they create many, many channels, even maybe redundant because they want to have isolation between channel A and channel B. If something goes wrong in channel A, channel B doesn't also get taken down. And so CTV can help with this by saying, you don't need to create all these channels, just create a single channel and we can do that fragmentation inside of the channel. Not worrying about that HTLC limit. So it helps with those sort of use cases.

SPEAKER_02: Okay. Well, moving on to implementation details for CTV, you've talked a couple of times about the happy case where only a single signature ends up being put on chain. But obviously when we're designing these protocols, we need to consider the unhappy case where you have this layer two protocol and you have a lot of state there from your OP CTV and you might have a lot of transactions and child transactions and descendant transactions. And so as you've been proposing this, this new opcode, obviously TV have also been making changes to Bitcoin core or proposing opening PRs in Bitcoin core. Um, can you talk a bit about those?

SPEAKER_00: Yeah, so I think there's sort of like two topics there. The first is in the unhappy case, what happens? And one of the things that I've been studying to sort of like simulate and loosely suggest but not prove because it's just a simulation that in these unhappy cases, CTV really helps with the congestion of a network and it makes it easier for somebody who wants to confirm some result that may make many outputs, get that result confirmed and then deal with the creation of the resolution later but lock in the result of that resolution, which I think is important for protocols being a little bit more agnostic to what the chain weather is if fees are higher, if they're low, they're kind of insulated from that. So I think that that's important where when you create a channel and when you don't know what the fees are going to be in the future and if you get stuck and there's a fee spike, you can kind of get locked out a little bit. Using CTV, you can kind of ameliorate that case a little bit and so I've done some analysis suggesting that CTV actually has a good impact in this regard. Specifically when you get to the changes in core that are coming to make this work a little bit better, the mempool is a data structure in Bitcoin which stores transactions that have not yet been mined and every time that you call this function create new block, what it does is it asks the mempool what are the best transactions that I can mine right now.

SPEAKER_02: So that's what the miners are doing. If you're just running a full node, you're not you're not doing that. But miners are trying to create the optimal block for them to collect the most fees.

SPEAKER_00: If you're running a node, you are storing the data structure that encodes the information to efficiently run this procedure, create new block, but you yourself are not necessarily calling that. So you're maintaining the list. You could answer this question pretty easily, but you're not actually asking for it. So most nodes do actually retain this information and do this sort. The reason why is kind of non-obvious, but everyone in the network is hopefully relaying these transactions, and you only want to be relaying and storing things that are likely to get mined and providing value to the network. So the more rational, essentially, the mining pool is, the better blocks that it will construct and also the less things that won't ever get mined that it's storing. A provably optimal mempool would be really impossible to implement, but what it would do is it would store every transaction that it's ever seen, and then it would solve an NP-hard problem to assemble the optimal block that spends those. So it's an NP-hard problem. That means that even if we, you know, Bitcoin core developers or Bitcoin developers generally, miners are really smart and working really hard, we will never write an algorithm that's optimal. It's just not going to happen. We might if computers get fast enough, but at the size of the problem, it's probably intractable. So instead, we write heuristics, and we do a best effort job. What happens to be the case is that best effort job, in a lot of cases, is not good enough. We have heuristics for when we evict transactions, and sometimes we evict a transaction or don't accept a transaction that otherwise actually might be good if you compare it to this infinite backlog mempool that picks things optimally. And so the goal of what I've been working on in one part is to help that become more rational and help it more closely emulate this perfect mempool.

SPEAKER_01: Okay, what places to learn more and how can people get in touch with you and ask questions and leave comments?

SPEAKER_00: Yeah, so I've been assembling a lot of resources on the website, utxos.org. You can go there and check it out, and that has a lot of diagrams, use cases, little articles about CTV and what the progress is. If you happen to be in San Francisco on February 1st, we're going to have a workshop, maybe the first of a few, but that's going to be an opportunity to review the BIP and go through and talk about what a deployment for this would look like. And I'm also available on Twitter at JeremyRubin, so definitely reach out and DM me or tweet at me and I'll try to respond.

SPEAKER_02: Great. Thank you, Jeremy.

SPEAKER_00: Thank you very much.

SPEAKER_01: So what do you think of CTV, John?

SPEAKER_02: I think it's really interesting, like I said in the podcast, I think it combines nicely with tap root and sick cash, no input or sick cash, any prev out or whatever you want to call that. Anything that allows you to encode within a single UTXO, multiple owners or multiple conditions, really opens up the door to more advanced scaling techniques.

SPEAKER_01: Yeah, but the orthogonal nature of, even if, let's imagine the tap group doesn't get merged. Do you think it's still compelling enough?

SPEAKER_02: I think it's still compelling. I think it's a pretty sad world if Taproot doesn't get merged, it isn't activated, but Yeah, these things stand alone, but I think combined together they become more powerful.

SPEAKER_01: Yeah, I really like the, just having vaults. I mean, people talk a lot about vaults and I think having vaults at the protocol level really replaces a lot of applications that are currently on the market. And that's, I think both good and bad. Sort of thinking about that abstraction layer, where do things belong? But there's very complicated applications currently that would be replaced by vaults, which I think is, which is a compelling use case.

SPEAKER_02: Yeah, new applications that would be enabled by CTV. So it's innovation and technical.

SPEAKER_01: Right. And the boost to Lightning was the other thing that sort of grabbed me. I think there are the part about having sort of like something similar to Channel Factories is somewhat interesting. But payment pools also, because I think the offline component has got to be. It is very important. It's one of the biggest drawbacks for Lightning for me.

SPEAKER_02: Yeah. Okay. Well, I hope you all enjoyed that episode. Please let us know what you think about the podcast.

SPEAKER_01: you should check out chenco.com and you can get in touch with us. I hope you enjoyed the show. Looking forward to the next time. Thanks, Janice.

SPEAKER_00: Bye. Music.

