---
title: Nadav Kohen and Payment Points - Episode 7
transcript_by: Whisper AI & PyAnnote
categories: ['podcast']
tag: []
---

Chaincode Labs podcast: Nadav Kohen and Payment Points - Episode 7

SPEAKER_00: On the Lightning Network, if I were to make a payment every single hop along that route, they would know that they're on the same route because every single HTLC uses the same hash. It's a bad privacy leak. It's actually a much worse privacy leak now that we have multi-path payments because every single path along your multi-path payment uses the same hash as well.

SPEAKER_02: Hi everyone, welcome to the Chaincode Podcast. I'm Cara Lee and I am sitting here with John. Hi, John!

SPEAKER_03: you Hi Carly, how are you?

SPEAKER_02: I am okay. I am sad that Jonas is not joining us, but it is due to the current circumstances in the world

SPEAKER_03: Yeah, Jonas is sheltering at home just like all of us.

SPEAKER_02: But we still wanted to go ahead and introduce this episode where you guys chat with Nadav Cohen.

SPEAKER_03: That's right. We talked to Nadav, who works at ShortBits with Chris Stewart. And ShortBits is a really interesting company. They are using the Lightning Network to monetize APIs and data streams. And Nadav writes a really, really interesting blog at shortbits.com slash blog where he writes about the technology behind the Lightning Network, discrete log contracts, payment points. And so we wanted to talk to Nadav about payment points specifically, which is a potential upgrade to the Lightning Network. Which we could get after Schnorr signatures are activated. So we talked to Nadav about that technology, about the advantages that it has over HTLCs and about some of the really interesting use cases.

SPEAKER_02: We hope you enjoy this episode and that you are all staying safe.

SPEAKER_00: Ain't a dove.

SPEAKER_03: and I'll see you in the next one.

SPEAKER_01: Hey. Welcome. Thanks for having me. So today, we're going to talk about payment points. And we're really excited about this. Can you maybe start off by explaining a little bit about an HTLC and how Lightning uses an HTLC? And then we'll take it from there.

SPEAKER_00: Totally. So HTLC stands for hash time lock contract, and it refers to the Bitcoin contract in which it has kind of two spending cases. One of them is a hash lock and the other one is a time lock. So if I set up an HTLC pointed at you, or spent to you, that means that if you reveal the pre image to the hash that is in that HTLC, then you can claim those funds. But if after a time out, you don't do that, I can kind of claw those funds back. So it has a hash lock on one side kind of to you and a time lock on the other side to me. And whoever claims those funds gets them. So how they're used in lightning is if I want to pay Carol through Bob, then I would set up an HTLC to Bob that says if you reveal the pre image to a hash that Carol knows. Then he can claim my funds and then I tell him where Carol is and he goes and sets up the same HTLC to Carol. And then Carol, who gave me the invoice for this payment, generated this hash knows the pre image, she can claim her funds. And now that she's claimed her funds, she must have revealed the pre image to that hash to Bob. And so Bob now knows the pre image and he can claim his funds. And so HTLCs are what the lightning network uses to make revenue. So it's a routing atomic between payment hops.

SPEAKER_03: So what do you mean by atomic?

SPEAKER_00: Atomic. By Atomic, I mean that no node on the network along a route is at risk of losing funds without being paid, meaning if their funds get claimed, they must learn the hash preimage, which must mean that they have the ability to claim the funds pointed at them. It's what makes everything risk-free in the sense that either the entire payment route will happen, or it won't, which is kind of what makes it one thing or atomic. Right. It can't be cut up. It's what makes everything risk-free in the sense that either the entire payment route

SPEAKER_03: Yep, and like real items. That's right. And what about the time lock? Component of that. So as you go along the path, yeah, with the times.

SPEAKER_00: So if, for example, your counterparty or the counterparty of any routing node along the route disappears or is just not responding, then you have all of these payments kind of set up and on Lightning you always have to be ready for the case where your commitment transaction ends up on chain. So essentially in order for things to be safe and secure and not trusting, you have to make sure that everything is working as if it's on the blockchain. And so if we're on the blockchain and I have this HTLC set up and the hash lock is never going to be claimed, meaning the payment has essentially failed but I'm on chain, then you want to be able to get your funds back seeing as things are atomic. Every single HTLC along this route will have failed. And so if you're not on chain, you can just get rid of that HTLC without using any kind of timeout, assuming that the parties are cooperating. But if you're on chain or if the parties aren't cooperating, meaning you have to go on chain, then you can just wait out that time lock and then claim your funds back.

SPEAKER_01: So HDLCs have some drawbacks, can you tell us about that?

SPEAKER_00: Yeah, so right now in the Lightning Network, if I were to make a payment that was routed, every single hop along that route would know that if they talk to each other, they would know that they're on the same route because every single HTLC uses the same hash. And so you're essentially like putting like a rubber stamp on inside each layer of the onion that kind of correlates that payment along that route. So it's a bad privacy leak. It's actually a much worse privacy leak now that we have multipath payments because every single path along your multipath payment uses the same hash as well. And so people can try and like find out where you are based on like intersections between paths and things like this. And then it also has the drawback that if you have two nodes, which could be the same person running those two nodes, or it could be two different people who are just cooperating, and they realize that they're on the same path, they can perform something called a wormhole attack where rather than revealing the preamp or so let's I'll give some names so that I'm not being too hand wavy, say that Mark and Mallory, both malicious, are on two nodes along a route, not neighbors, but just two nodes along a route where Alice is paying Bob some external to them. And they see that they're on the same route because they've set up HTLCs with the same hash. And now Mark is going as further along the route, and he's going to learn the preimage. And now rather than claiming the funds pointing at him using that preimage, he directly tells Mallory not on the Lightning Network, just however they're communicating what the preimage is. And she claims her funds using that preimage and you kind of have just skipped over all of the intermediate nodes between Mark and Mallory. And presumably, I mean, if they're the same person behind them, they don't care that Mark didn't get paid, they still ended up getting the money that they were owed. And if they're different people, maybe they have some backdoor deal where they pay each other. But essentially what's happened here is that they've stolen the fees of all of the nodes in between them, because the kind of difference between what Mark would have made and what Mallory did make is those fees. And not only have they been able to steal all those fees, which are kind of the payment for the use of the liquidity of the nodes in between, but also if Mark wants to, he cannot fail the payment, he can just like hold on to it. And all of the nodes in between them will have in-flight HTLCs indefinitely until, well, not indefinitely, until the time lock occurs. And that's when the payment actually will fail. So you can kind of hold their funds hostage to the worst case scenario. And it's completely undetectable, because to them, it just looks like the payment never happened and that the payment failed. And so there's not really any mitigation against this. And also, you're economically like incentivized to perform these attacks, because you get paid to do so.

SPEAKER_03: But Alice and Bob don't care about this, right?

SPEAKER_00: Alice and Bob don't care about this. This is correct. This is, uh, something that only affects routing notes and it sort of seems like it's a more efficient route. I mean, yeah, it is, it is more efficient route. Um, yeah, but, uh, so, so the, I would say the main problem is definitely the, the privacy leakage that happens with HTLCs, but then also, you know, it can be problematic that people are incentivized to kind of steal fees from people in between and hold their funds hostage, but although they're not incentivized to do that, they just, it doesn't matter to them.

SPEAKER_01: It is So, are there solutions that could improve this? Yeah, so,

SPEAKER_00: solutions. Yeah. So there are these things called pTLCs, which are point time lock contracts. And these are essentially the same as HTLCs, except for instead of the hash lock, we have a point lock. So instead of saying, reveal the preimage to this hash, we say, reveal the scalar to this point, which is analogous to saying, reveal the private key to this public key, except for I try to say scalar and point because private and public, normally you shouldn't be giving people your private keys, but it's okay to give people scalars to like points that aren't being used as keys most of the time. Yeah, but so essentially in Bitcoin script, there isn't actually a way to like compute the point to a number, but there is some math magic you can do with adapter signatures on Schnorr. It's very easy to do adapter signatures on ECDSA. It's quite a bit harder, but using adapter signatures, you can essentially enforce point locks in kind of like not a strictly on chain sense. And yeah, you can create pTLCs and then you do everything else on Lightning exactly the same, but rather than having the contracts be set up in a way where you're revealing pre-images to hashes, you reveal scalars to points. And the reason that this helps us is because with hashes, you're destroying a lot of useful, non-sensitive information about your pre-image. So you can't do anything with a hash of something. Whereas when you have a point of a scalar, certainly you get no useful information about the scalar, or at least no sensitive information about the scalar, because if that were the case, public-key cryptography would be kind of screwed, but you still get some nice properties, specifically an additive property where if I have two scalars and I add them together and then find out what the point is, that gives me the same results as if I took the two points corresponding to those scalars and added those two points together. And so what we do on the Lightning Network with PTLCs is we add a random nonce to every single hop, and that completely decorrelates them because every single kind of PTLC uses a random point. Well, yeah, just a random looking point, I guess I should say. And then, so everyone kind of adds this tweak on the way forward. And then when a preimage or a scalar is revealed to you, then you subtract your tweak on the way back. And so this has a couple nice properties. A, it decorrelates all of the payments. No two people can know that they're on the same route, at least not nearly as easily, because there's no linking information other than a mountain distance and all the usual things you have to worry about with the Lightning Network. And then also you have the nice property that only the sender learns the true preimage that is the preimage to that invoice. So in a lot of Lightning applications today and probably in the future, we have this thing called proof of payment, which we essentially treat the hash preimage as a proof of payment, since it's received atomically with a payment being completed successfully. Only if your funds are claimed, do you learn the preimage to this hash. And then you can use that preimage as kind of a receipt in various senses. You can use it as a literal receipt if you're doing like accounting. You can also use it as at the application layer as kind of like a lock on the payment. So for example, at SharedBits, we have APIs where you buy data from us over the Lightning Network and how you do it as you ask for it. We give it to you encrypted with the payment hash preimage. And then once the payment is completed, you now have the preimage. And so you can decrypt that data if and only if we receive your payment.

SPEAKER_03: And that's a really nice model because it's kind of stateless from your side, right?

SPEAKER_00: totally yeah so if we go down and our lightning note is still up or something like that like if our api goes down or something like this if you pay you get the data it doesn't really depend on anything external um yeah and but the issue with this right now in the world of htlcs is that every single hop along the route gets your proof of payment so they can like go to a website and be like i paid that invoice even though you were the person who actually lost funds during that lightning transaction and then

SPEAKER_02: Yeah.

SPEAKER_03: potential attacks if the invoice does not have an amount you could someone on the route could somehow

SPEAKER_00: Yeah, I think this is a somewhat separate issue. I I think this isn't solved by few TLCs Okay, um invoiceless Transactions on the lightning network are quite tricky. Okay In part because the person receiving doesn't inherently know how much they are supposed to be receiving So like the hop before them could like take a super huge fee or something like this that they aren't supposed to And I believe there are mitigations against these things like you can put Information inside the TLV of the onion or something like that, but I don't know that that's been standardized But yeah, um for I I think that With HTLCs the the main problem is just it's it's yet another concern on the application layer If you want to use the hash pre-image you have to like mix in someone's pub key Which means you need to get someone's pub key these kinds of things. Um, and so With pTLCs, this is kind of solved because since there's a tweak Along every hop along the way that gets added on the way forward and subtracted on the way back Only the original sender of the payment learns the pre-image and it can be really used without as much hesitation, um as a as a receipt that can be used to Make things atomic with the lightning payment

SPEAKER_03: Can we make things a little bit more basic and go back to HTLCs? So Alice, Bob, Charlie in a payment route. Alice is paying Charlie. Who chooses the pre-image and the hash and how do those get communicated and how is that different for PTLCs?

SPEAKER_00: Yeah. So in general today on the Lightning Network, the person getting paid, so in this case that would be Charlie, generates the invoice and puts it somewhere or sends it to Alice, not on the Lightning Network. And then Alice is then the person who sets up the payment. She decides what the route is. She decides to go through Bob and computes the fees and all of these kinds of things. She constructs the onion, which is the message that gets sent through the Lightning Network.

SPEAKER_03: And that invoice that Charlie created has the pre-image. It has the hash.

SPEAKER_00: The payment hash is going to be inside the invoice, which Charlie created, and Charlie keeps somewhere the preimage to that hash. And then Alice goes ahead and sets up an HTLC to Bob, and Bob peels his onion and sees that he's supposed to then set up a payment to Charlie with the same hash. And Bob does not know that Alice originated the payment. Alice could just be another hop on the route. And Bob also doesn't know that Charlie is the last person on the route. Likewise, Charlie doesn't actually know that Alice is the person paying him, necessarily. He just knows that he has been paid for this invoice. So those are some nice privacy properties that we have. And very briefly, the onion. Yes, the onion. So essentially, how you keep things nice and private while doing routing over the Lightning Network is the person who is initiating the payment, in this case, Alice, generates an onion. And what you do is you kind of go backwards, starting at the end of the route, and you create the message that you want to give the last person, and you encrypt it with your shared key to them, with their keys, essentially. And then you take that message, and so now that it's encrypted, only they can read it. Then you write your message kind of like on the outside of that to the next person, and you encrypt that, and you keep adding layers, which is why we call it an onion. And so as you pass this onion, people kind of like peel back one layer, read what they can, and then they can't read anything more because it's encrypted, and then they pass it on. And the bit that was added just for them tells them where they pass it on. Yeah, exactly. And onion is not the best analogy because the onion doesn't actually lose size when you peel it. It just like gets more garbled, so to speak. All onions are the same size. So peeling is kind of like you take off a layer, and then you add on like a fake layer on the inside or something weird like that. I don't know exactly how it would be a good analogy. We don't have a vegetable that looks like an onion.

SPEAKER_03: Yeah. OK, so that is HTLCs. PTLCs, same onion. Same onion. Same routing. Same routing. Charlie is going to create the secret justice before and create an invoice. Yep.

SPEAKER_00: Yep, and so he puts the point in the invoice rather than the hash and then Alice Now generates the onion and when she generates the onion There is an extra step for Alice and what that extra step is is for each hop along the route and she computed that rep She generates a random number Random scaler and then computes the points to those scalers and then in the onion she kind of has an additive tweak on each of those hops and In the onion, which is a personalized message to just that one hop She also tells each person what their scalar tweak is and so because they need to subtract it on the way back And so then in the protocol everyone adds their point on the way forward so if someone if my tweak is like capital B if Bob's tweak is capital B and He has received a PTLC pointing at him with the point a Then he would set up a PTLC with the point a plus B Moving forward and then when he receives the pre-image like lowercase a plus B He subtracts lowercase B and reveals lowercase a to the person in front of him So everything is the same as HTLCs in kind of the process Except for these additive tweaks on the way forward and subtractive on the way back

SPEAKER_03: And so for the routing nodes, it's basically the same, except that the commitment and the reveal is a point in a scalar. Yep. But for Alice, for the payer, she's the only one who gets that original secret. Exactly.

SPEAKER_02: Yep.

SPEAKER_00: Exactly. Uh, she's the only one who gets the original secret. And then as far as the process goes, uh, she has to generate all of the tweaks. And I forgot to mention, she also, the, the extra wrinkle that's different from HTLC is as she reveals the sum of all of the tweaks to the last person, Charlie in this case, because Charlie needs to be able to satisfy his PTLC and his PTLC is going to be the sum of all the tweaks plus his point. And so he knows the preimage to his point and he needs to be given the preimage to the sum of all the tweaks, but that's just done in the onion, um, as you'd expect.

SPEAKER_01: And so it sounds like this is just superior in every dimension. Yes

SPEAKER_00: Yes, so not only does it give you payment de-correlation and protection against wormhole attacks, but also you can do all sorts of other fancy stuff with it, which I assume we'll be talking about shortly.

SPEAKER_01: Yeah, I mean, before we get to that, like, why have why hasn't this been pushed harder? Yeah, sounds like this is just looking it up. It looks like it's been around for a while. Yeah. Why is this not sort of given the issues that are that we currently know about HDLCs? Why wouldn't we?

SPEAKER_03: Yeah.

SPEAKER_01: go to PTLCs now and figure out how to do it better in the future. Yeah.

SPEAKER_00: Yeah, so first thing to note is that in order to implement PTLCs as opposed to HTLCs, you need to implement some stuff that is not already available in Bitcoin script. So HTLCs are just native to Bitcoin script. They're currently implemented using stuff available on the base layer. Whereas to implement PTLCs, we need to either introduce a signature system that has nice adapter signatures, which is kind of the plan with Bipshanor. But we could also implement adapter signatures for ECDSA. But we just don't currently have any nice, well-tested libraries for doing this. I've kind of asked around people who I know who are working on LibSecP. And it sounds like they find it interesting, but they also think like Shnor is better. It's better not just in that we're getting it and everyone will be using it, but also that Shnor adapter signatures have better security guarantees than ECDSA adapter signatures. They give you a bigger anonymity set. They do lots of other things in superior ways to ECDSA adapter signatures. And so I guess short answer is no one has ever gotten around to implementing ECDSA adapter signatures in a nice, tested library. And part of that is lightning is relatively new. And HTLCs have not been the biggest issue that has been kind of the active field of work in lightning. We're working on various liquidity issues, atomic multipath payments, rendezvous routing, trampoline routing, all these kinds of other issues. And this payment points has kind of taken the back seat because we know that Shnor is coming to fix it. And so.

SPEAKER_01: But you think that's the sentiment is is snore arrives and this is a drop in solution that's

SPEAKER_00: That's what I understand of it, and I know that I'm going to be pushing to make sure that we're implementing PTLCs hopefully before Schnorr even hits the base layer for lightning. But yeah, I think I saw in March of 2017, there was an email post by Andrew Pulstra showing how to do lightning channels using PTLCs in Schnorr. And so I think we know what we want to do, but we're just kind of waiting for Schnorr to hit base layer before we go ahead and implement this.

SPEAKER_01: So all those, that magical timeline sort of unfolds and then, and then what else, what else could you do? Like what else, what does this unlock? Yeah.

SPEAKER_03: and then

SPEAKER_00: 2 weeks Yeah. So it unlocks quite a few pretty cool things. So most of them have to do with the additive property of points. You can add more things in. And then there's some other fancy point stuff you can do, but I'll get to that probably in a second. So I think the first really cool thing that you get is there are a lot of proposals going around right now, some of which are already implemented on the Lightning Network, such as multipath payments. Another example is invoiceless payments, which are also known as spontaneous payments. I think those are implemented on LND right now, but I could be wrong. And both of these have an issue when using HTLCs that since the sender has to do some of the work in constructing the payment hash, it turns out that since we're using hashes, they have to do all of the work. There's no input that you get from the last person. And so you already know the preimage as the sender. So this isn't actually an issue. You don't have any problems in terms of the atomicity or security of completing a lightning payment. If the sender, the person who initiates the payment, knows the preimage because they never reveal it to anyone. And so it would be an issue if someone like along the route knows the preimage early. But if the person who is initiating the payment knows the preimage, it doesn't actually have any adverse effects. So for example, how a spontaneous payment works is say we have Alice Bob and Charlie again, Alice, without an invoice, creates a payment, she generates the preimage, she generates the hash from that preimage, she sets up the onion in the same way. And then in the innermost part of the onion, the part that only Charlie can read, she writes down what the preimage is. So now this gets passed forward, peeled, peeled, peeled, Charlie gets it. He's like, Oh, a payment. What's this opens it up sees that the preimage is written inside, and then he can go turn back to Bob and claim that payment. And this is how that works. But it has the issue that you have no proof of payment, because Alice has learned nothing. By having she knows that Bob has she knew the preimage to begin with, so she can't use it as a proof of payment. And the same is true for multipath payments right now. The sender generates the preimage that they then get revealed to them at the end. And there's some other proposals. Stuckless payments would require the sender do some work in these payments that are called stuckless payments. And that would mean that they would have no proof of payment in that scheme either. And just generally, they're a decent number of cool things we can do on lightning, if we're willing to sacrifice proof of payment, which is sad for, you know, like us at shared bits, where we're trying to use the proof of payment as a way to create like lightning, paywalls and stuff like this. So all of this is kind of easily solved with payment points by just adding the stuff that needs to be generated by the sender, plus stuff that is known and generated by the receiver. And then, so as an example, with like an atomic multipath payment, rather than having the sender generate all of the preimage and then just having it so that the preimage gets discovered by the receiver when all of the paths are set up, you can do all of that, but then also to each of these paths, add a point that is generated by the receiver. And so then the receiver still learns what the points generated by the sender was, or what the scalar sorry generated by the sender was. And then they can just add that scalar to the one they know, and then reveal that. And then when that gets back to the sender, the sender learns kind of the sum and they know their parts, they subtract it away, and they can use the other part as proof of payment. So essentially, just add the receiver's point to anything and you get free proof of payment for everything. So that's kind of the simplest non-magical math thing you can get using PTLCs instead of HTLCs. I'm trying to pick which one to do next. Do you have a favorite?

SPEAKER_03: Well, you mentioned something there called Stuckless Payments.

SPEAKER_00: That's intriguing. Yeah, so Stuckless Payments is a proposal where rather than, so currently kind of the situation I described, you have a payment setup phase immediately followed by a payment kind of completion phase. I forget what the actual name for it is in Stuckless Payments, but that's what we have. And the proposal is to add an update phase. So rather than having, so say, think about it in terms of spontaneous payments for HTLCs, because you can't have proof of payment with HTLCs. So if I have a spontaneous payment, but where I don't write the pre, where Alice doesn't write the pre-image inside the onion, and instead tells Charlie like what, like Tor address to go ping and ask for it. And so essentially the idea here is, is that if my payment gets stuck during setup, I can safely retry another payment because the actual pre-image only gets revealed to the person, to the receiver of the payment once. So since the sender knows the pre-image and just like tells Charlie, Alice tells Charlie where to go ask her for the pre-image. And she can set up as many routes and try as many payments simultaneously, or in sequence as she wants with Charlie. And the first one Charlie receives, he's gonna go ask her for it. And she's going to reveal it to him. And she's, by the way, I should have mentioned, she's using different pre-images for each of these payments she's setting up. Otherwise that would kind of defeat the purpose. So yeah, anyway, the first one Charlie receives, he goes and asks for the pre-image and Alice makes notes, makes a note of this and makes sure not to reveal any of the other pre-images to him. So Charlie should just fail the rest of the payments. And so upsides and downsides to this proposal. The only downside is that Charlie has to go find Alice via some other means. There've been some proposals that he uses an alternative route to just send a message over the Lightning Network or various other things that use the Lightning Network, or you can just post something on Tor and go out of band. But however it happens, if we have that extra round trip available to us, then what we can do is we can have Alice kind of retry or set up simultaneously as many payments as she wants and have only one of them be completed. And it also is nice and interoperable with atomic multipath payments. So she can retry sub payments in an amp. And yeah, I think probably how this will actually manifest is you try a payment and you wait a second or two. And if it's still not done, you just try again on a different route to try and improve the payment experience on Lightning. And another cool thing to mention about it is that only the receiving and sending notes need to have the feature implemented. All of the routing nodes, to them it just looks like a normal payment that either fails or succeeds. And so this can be like an odd feature bit on a, no, I guess bite, an odd feature bite on Lightning, meaning that not everyone has to have it implemented in order for everyone to coexist and do their thing. So how do PTLCs play into this? So PTLCs just add proof of payment to the scheme. So if you do the scheme using HTLCs, Alice must generate the preimage entirely rather than just a part of the preimage as she would in PTLCs. So with PTLCs, you can, because right, if you're trying to do, if this becomes like the norm on the Lightning network where all payments are stuckless payments or even a majority or many payments are stuckless payments, it would be a real shame if we just like got rid of proof of payment entirely on the Lightning network. And with PTLCs, we don't have to. And what happens to all of those failed payments? They act like normal failed payments on the Lightning network. So they kind of propagate backwards from their point of failure with failure messages kind of going backwards on the onion, essentially. And everyone just gets their funds back. And if anyone like tries to hold off on that, then you go on chain and use the time lock. But normally payments just like pretty quickly fail. You update and remove that HTLC from your commitment transaction. Yeah. And not to downplay like the fact that right now on the Lightning network, it is very spammable. Please don't, but like you could spam it in lots of different ways. You could pay yourself and hold on to those and fail those. And essentially because of the routed nature of the Lightning network, your costs to hold up other people's money and just like lock it up, you get like a 20X multiplier on your funds. You can just take a long route to yourself and hold up like a little bit of your funds and like the same amount of like 19 other people's funds and channels. So I know that there are people working on the spam problem and I think it's really important, but.

SPEAKER_03: Okay.

SPEAKER_00: we don't have too much spam on the lightning network right now luckily so let's keep it that way yeah let's for a little bit till we till we figure it out

SPEAKER_03: Let's keep it that way. Yeah.

SPEAKER_01: Let's talk about a few other things. Sure. Yeah. Tell me about escrow contracts or selling signatures or anything else that you're excited about.

SPEAKER_00: Totally. Yeah, so Schnorr signatures, although they aren't on main chain right now can still be used off of the main chain in things like discrete log contracts. And also, I just realized, since payment points, I mean, so if we implemented payment points today, meaning like ECDSA adapter signatures, we could still use Schnorr signatures off chain. And so that's what I'll describe here. So Schnorr signatures have this nice property that, well, first of all, for those who don't know Schnorr signatures, like the resulting signature is a scalar, it's just a number. And so for any number, you know, you can compute a point on an elliptic curve. And so if you take like the signature times G, or you take the point of the signature, essentially, the public key, if you treated the signature as a private key, if you take that point, you can actually compute that point from the signers public keys without knowing anything about the signature. And so what this means is that you can on a PTLC lightning network, pay someone for a valid digital Schnorr signature of a specific message in a completely trustless fashion, you can from their public keys, compute the point associated with that signature, and then make that signature or make the scalar behind that point, which is the signature, your proof of payment. And so you can trustlessly pay people for their signatures. So for example, when I mentioned earlier that at shared bits, we are encrypting data with the payment hash pre image, that requires that you trust shared bits that we're not just giving you like garbage. And if you wanted to pay us right now over HTLCs, for a specific piece of data, you could not without some very heavy zero knowledge proofs, verify before completing that payment, that we indeed were giving you the encryption key for that, or the decryption key for that. Whereas, once we have payment points, you can trustlessly pay people for their signatures of specific messages. And you can actually you can go kind of a step further, so I can add these points whose pre images are signatures to anything else. So you can make contingent payments where the payment is contingent on the receiver learning of a signature. So an example of this would be, say I have an Oracle someplace that will be signing a specific message if Bitcoin is over 10k at the end of this weekend, or something like that, then and say I want to pay you like 10k satoshis if this happens just as like Oh, it happened. So I get a point from you, which will be my proof of payment. And then I compute from the Oracle's public keys, the point that would be associated with their signature, the point whose pre image is their signature of like moon or whatever message they decide to sign. And then I add these two points together. And I use that as the point in my PTLC. And now you won't be able to claim this payment unless the Oracle signs this message. And so if they do, then you just add that signature to your pre image and you get kind of the sum pre image, which is the one you need to claim this PTLC. And I will see that my funds have gone and at the same time, get this signature from the Oracle as part of my kind of payment completion, as well as a proof of payment from you. And you can kind of just do this generally, like you can add as many six together as you want. They can be oracles, they can be like other parties involved in multi party schemes. But you can make contingent payments on signatures being revealed. And the really cool thing with all of this payment point stuff is like everything is interoperable, like you can have stuckless amps, in which I'm doing like a multi party thing that's using payment points that's using like signature revealing as part of it and stuff like that. And yeah, so there's there's all sorts of kind of like interoperable things, which brings me to the next thing you can do with payment points, which is these escrow contracts. So some something of a similar flavor to kind of these signature contingent payments, but somewhat different in how they work and kind of what the trust in execution model is. So say that, um,

SPEAKER_01: you

SPEAKER_02: Yeah.

SPEAKER_00: out or yes, say that Alice wants to pay Bob, if Bob cleans her house or something like that. There's some some thing in probably the real world doesn't have to be in the real world. But let's say it is. And so they they both agree to some third party, which we call an escrow, say like Aaron, who they both trust to report truthfully whether or not Bob has cleaned Alice's house. Now, they don't actually contact Aaron necessarily, or they don't have to tell Aaron what they're what she's being used for, or just generally, there's a nice kind of privacy layer here. And so what they do is they take us like a signature from Aaron, because they know her public keys, and they compute a point for signature from Aaron. And then they so essentially, what we want here is we want a payment to go through if Bob and Alice or Bob, and Aaron agree that this payment should go through. So either Alice can say you clean my house. Well, here you go. And the payment should go through. Or if Alice isn't there, or Alice is not cooperating, then they can go to their mediator Aaron and Aaron along with Bob can help this payment go through. And so how we do this is we take Bob's point, and we add it to we want a point that can whose pre image can be computed by either Alice or Aaron. So, so far, we've just been talking about how you can add points together. And that essentially acts like an and logically. And it turns out that using some fancy math, you can usually create these or points. There are a couple different ways of doing this. One of them is verifiable secret sharing. Another way of doing this is through verifiable encryption, which is probably what you would do in this case. And so what that means is, you have Aaron's public keys, so you can encrypt things that only she can decrypt. And so what you do beforehand is Alice will verifiably encrypt meaning encryption plus some simple zero knowledge proofs that you're following the rules of the encryption. And so Alice verifiably encrypts her pre image her scaler, using Aaron's public key, and then she gives this encrypted value over to Bob. So now if Alice agrees, she just reveals the scaler directly to Bob, if Bob has cleaned your house, and now a plus b, Bob has the pre image he needs to claim this payment. But if Alice isn't agreeing, Bob can go without Alice's permission to Aaron, give her this encrypted value. And if Aaron agrees that Bob has cleaned Alice's house, then Aaron can decrypt this value and give it to Bob. And this value is the pre image that Alice generated. So you can do these kinds of or schemes. And in general, these points with what are called monotonic access structures, that's just us an access structure is just like, what are all the sets of people who can collaboratively compute the pre image to this point. And so a monotonic access structure is just all of the access structures made up of ans and ors. And so I'm not too comfortable claiming you can get all of these with all of the different constraints on privacy and all these other things. But you can usually find a way, sometimes more complicated than others to create ors as well as ans. And so and as I mentioned, all of these things are kind of composable. So you could have it like, be this escrow or this oracle and this person or you know, whatever else. And you can make all of these kinds of interesting contingent payments and contingent payments is just another way of saying contracts, right, like a smart contract is really just a contingent payment, where the execution can happen in various ways. And in this case, you can always kind of abstract your execution to like, someone signing off that the execution did something or something like that. So we're not kind of just confined to Aaron said, Bob cleaned Alice's house. Aaron could also say that the result of running this program with these inputs, like this arbitrary program is like this output or whatever, and she can sign that message. And then you can use that in a contract. And so you can get these pretty general contracts, just from having payment points lying around, and everything to everyone not involved in these payments looks like a normal lightning payment, just like it does right now with HTLCs. Yeah, and you can do even more with payment points that I'm not even talking about right now. I won't get into how these work because they're quite complicated. But I claim and I have yet to write it up to formally it's on a mailing list post somewhere that you can do atomic multi payment setup. So you can set up multiple of these contingent payments in various directions between a ton of parties, and you can have all of the setup kind of happen atomically, so that you don't have a problem of like, I set up a payment to you and you haven't set up one to me yet. And then you can also do payment renegotiation, where you like, complete it like you cancel out ish one payment while setting up another one under different circumstances. So this came out of work dealing with dealing with like, you have a discrete log contract set up using payment points on lightning and you want to sell your position to someone else. And you can do that using lightning and you can't do that on chain, which is cool.

SPEAKER_03: Cool. Well, maybe we can have you back on the podcast once. That's right. Talk about all those kids.

SPEAKER_00: Yeah, I'm working on the blog posts as we speak, so this should be out soon-ish at SharedBits.com slash blog.

SPEAKER_03: We will include that link in the show notes. Okay, just to wrap up, when payment points- when pa-

SPEAKER_00: Thanks for watching! When payment points to know when snore hopefully very soon after that I'm very hopeful that the more the closer snore gets the more people you know take time aside from their busy lightning developer lives to like go look at my you know fancy theoretical not useful right now payment point write-ups and stuff like this get super excited and then go implement it so that would be great

SPEAKER_03: Thank you so much. That was great. Thank you so much.

SPEAKER_00: That's great. That was fun.

SPEAKER_02: We hope you enjoyed that episode.

SPEAKER_03: Well, I really did. We had a great conversation with Nadav and I think payment points are fascinating, especially the use cases that they open up.

