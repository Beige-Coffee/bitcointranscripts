---
title: Chaincode Decoded- Bech32m - Episode 11
transcript_by: Whisper AI & PyAnnote
categories: ['podcast']
tag: []
---

Chaincode Labs podcast: Chaincode Decoded: Bech32m - Episode 11

SPEAKER_01: podcast is back welcome back to the chain code podcast I am here with merch hey there and we are back it's been quite a layoff but we're back in the studio and happy to be here very happy so today we are going to revisit a segment called chain code decoded where we're gonna be going into Bitcoin fundamentals and we are going to start with betch32 and betch32m hope you enjoy happy to be back

SPEAKER_00: Thanks for watching!

SPEAKER_01: Let's talk about Betch32. All right. What's going on there? Maybe we'll start with the pronunciation. Are you sure it's Betch32?

SPEAKER_00: Alright. The inventor of the name I think calls it BESH 32. I've heard various other pronunciations like BESH 32 or BESH 32. I don't know. BESH 32. Okay.

SPEAKER_01: Mm. I dunno. Okay, so BESH32, why do we need this new format?

SPEAKER_00: Previously, we had addresses that were encoded in base 58 check base 58 check uses a character set of 58 characters. And that includes mixed case. So it's case sensitive. And it's just a headache to copy these. Have you ever tried to dictate a an address on the phone or something? Unfortunately, just writing it down is yeah, because you have to constantly look twice was it an uppercase lowercase we think of the letter we don't think of a capitalized or lowercase. Anyway, that that was a bit of a headache. It's nicely compact, because you can encode so much information with a big character set. But the mixed case is just a huge downside. So when SegWit got proposed, a new address standard was proposed with a 32 character set, resh 32. And one big advantage of that besides it having much better error detection was that it would be single case. So it's either allowed to be lowercase or uppercase, but mixed cases explicitly forbidden.

SPEAKER_01: Unfortunately, just writing it down is not that fun. transits. And so it's 32, which gives you the alphabet, which is 26, plus some numbers. Or what? What characters were you moving?

SPEAKER_00: So actually, the characters that are forbidden are 0, I think, O, L, probably.

SPEAKER_01: OK. We take some out because they can be confusing when you're looking at them visually.

SPEAKER_00: when you're looking at them visually. The ones that look like other things, like L looking like 1 or i, and O looking similar to 0, and so forth. Anyway, it's just 32 characters, which is a multiple of 2. It also can be completely lowercase. So the standard case is actually just to make the addresses completely lowercase. Uppercase is explicitly allowed, though, because, for example, when you encode addresses as QR codes, you can use a smaller instruction set to encode uppercase. And it makes the QR codes just look like the complexity of the QR code goes down a lot. And it's easier to pick it up with a camera and stuff like that. So especially in QR codes, you actually want to use all uppercase.

SPEAKER_01: Right. I'll see you next time. Cool. So we have this new format, and then what do we do with it? What's the distinction between native SegWit and Batch 32?

SPEAKER_00: a lot of people use that interchangeably. So native segwit describes a type of output format, whereas Besh32 describes an address encoding. And Besh32 especially is used for native segwit v0 outputs, which is pay-to-witness public key hash and pay-to-witness script hash. And actually, it's also used in other things. I know that lightning invoices get encoded in Besh32. I think there is also a PGP alternative that encodes their pub keys in Besh32. But it's basically a public standard, and other people have picked it up because they've went a lot of work into making a format that has very nice error correction properties.

SPEAKER_01: So why does Taproot need a new address format then?

SPEAKER_00: Excellent question, yeah. The BIP 173, the definition of the BESH32 address format specified that it should encode all addresses for SegWit v0 through SegWit v16. You might remember that SegWit introduced versioning for the script language and only the script inside of the SegWit scripts gets versioned in the witness programs. So the first one that got defined was SegScript and it was v0 SegWit and it gave us basically four different new address types, or I should say output types if we're correct here. The wrapped SegWit types, which is a backward compatible format because the witness program gets embedded into a pay2script hash output. So when you spend it, you first have to prove, look, I know what the original preimage for that hash was and now please go over there and solve that witness program. And that works for pay2witness public key hash and for pay2witness script hash. So either of those can be embedded in a pay2script hash address, which made it great for forward compatibility because basically pay2script hash rolled out in I think 2012, 2013 and all wallets could send to pay2script hash addresses, especially because a lot of big exchanges used multisig. So they wanted pay2script hash and wallets could support that out of the box. Now, the other two output types that got introduced were native SegWit outputs in the sense that they did not have this pay2script hash wrapper, but they actually just directly had you resolve the witness program. The problem was that a lot of wallets obviously didn't know how to deal with the new address format because the new address standard had just been proposed even slightly after SegWit was proposed. So in order to be able to pay to an output, you either had to just know what script to put there or you had to be able to decode the addresses and then generate or find the script from that. And especially this decoding step that was missing until wallets had Bash32 decoders. So it took a while for a lot of wallets to be able to send to native SegWit outputs. And since that is a very painful process, it was in the spec, well, specified that it should work out of the box for version 0 through version 16. And you should respect the version that you're given and then just send to the address that you're given because nobody would give you addresses that have no meaning on the network, right? They would just be burning funds and they wouldn't have gotten paid. So they made somebody else pay into the void and that other person could prove to them, hey, you gave me that address, you got paid, there's your money. If you can't get it, well, that's your mistake, not mine, right? So basically, it's safe to be able to spend to higher versions of SegWit. And that was the specification. But now that Taproot became more imminent, people were actually testing whether wallets were ready to pay to Taproot address, which are native SegWit V1 addresses. And they found that not only had a lot of wallets basically curbed any versions but V0. So they would just say, oh, address invalid, which is sort of safe, maybe a little much hand holding, but not wrong per se. But much worse, they found that some wallets ignored the version parameter and downgraded the address to V0. So now let's remember SegWit is versioned and the script has meaning within the context of the version. And now when you try to send funds to a version one address and keep the script the same but then label it as a version zero address, you're actually creating something that is unspendable, you're burning funds. So this was a very popular wallet service and they were basically, if given a version one address, they would burn the funds. They would literally say, oh yeah, it looks good to me, and then create a transaction that burned the funds.

SPEAKER_01: Given that we're talking about wallet services, isn't that on them? Like, why is that a protocol issue?

SPEAKER_00: Yes, it's on them. And they basically didn't correctly implement the spec. I guess that would be a valid stance to take to just say, well, if you're burning your customers' funds, that's on you. But the service in particular has had a very slow response to SegWit in the first place. And who knows when they'd get around to fixing it. Until then, there's just a very large portion of all Bitcoin transactions going through that service. And given that a lot of other services also already had to make minor changes in order to be able to send to V1, just setting it to enabled addresses or allowing these types of addresses, this change that we're introducing with Bash32M on the sending side is very minor. So basically, if you have to touch it already, if you change two lines instead of one line, you'll be fine. But better than...

SPEAKER_01: Yep. Yep. But better than burning our kind of funds. And I guess the other approach would be standardness. So making these anything other than v0 non-standard.

SPEAKER_00: SegWit v0 addresses are actually only allowed to have two fixed lengths, and one of them is 42 characters, which is for paid-to-witness public key hash, and one is 62 characters for paid-to-witness script hash. And the way that taproot is proposed, it will also basically just have a 32-byte hash. So they're exactly the same length as paid-to-witness script hash. If they were using the same address format, other than the version 0 and version 1, there's no difference between the space that they're allowed to be in. By downgrading to v0, they would essentially be creating a valid output type that is to be interpreted as a paid-to-witness script hash output, but it cannot be resolved as such because there is no script hash that resolves to it, because taproot uses a pubkey. It's not compatible. People wanted to prevent that from happening on the one hand, and on the other hand, about a year or I think two years by now ago, someone discovered that Besh 32 actually had a length extension mutation weakness. You can think of Besh 32 addresses basically just as a huge polynomial. The character set, the 32 characters, are just encoding numbers from 0 to 31, and each character position is the factor of one of the polynomial terms. And now it turns out that because the checksum was using a constant of 1, when you have an address that ends on the character p, which encodes the value 1, you can insert q's or remove q's right in front of the last letter p, and the q encodes the letter 0. Mathematically, that is equivalent to just multiplying all other polynomial terms with another x, and it turns out that that is another valid Besh 32 address. So what Besh 32m does is it changes the constant in the checksum to something much bigger, which is not part of the 32 character values, and it gets rid of this type of error.

SPEAKER_01: Okay. Okay. Thanks for watching! Got it. Very good. So that's what we're going with going forward.

SPEAKER_00: Right, so basically the literally only thing you have to do is, oh, if there's a version one or higher here in the address now, I have to run a decoder that uses a checksum with this higher new value instead of one. Literally the only change people that want to send to this address have to make.

SPEAKER_01: Great. Any last words on maybe the implementation of BEC32M?

SPEAKER_00: You don't have to do anything to continue to be able to send to SegWit v0 outputs because the address format for them doesn't change and it's also not really prone to the length extension tension mutation because the addresses are limited to these two specific lengths. And now if you implement support for sending to all the new and higher versions, be sure to check that it goes through with all the test cases from the BIP. There are test cases that make sure that all the BESH32 addresses do not properly resolve to BESH32M decoders and vice versa. All BESH32M addresses don't properly resolve to BESH32 and you should be able to pass all the test cases in the BIP. And that includes being able to send to all higher versions than one so that when we roll out, I don't know, SIG hash no input eventually or other new address formats that might come up in the future, everybody will just be able to send to them and we won't have a multi-year headache where nobody knows whether it's safe to default to native SegWit addresses yet or things like that.

SPEAKER_01: Thanks for a great conversation, Merch. Yeah, this one was fun. And looking forward to the next one. I think we're going to do Mempool next.

SPEAKER_00: And that's all for now. Everybody has been talking about the mempool in the past few months because it's been a bit congested

SPEAKER_01: That bull run. Yeah, everybody's upset about the bull run.

SPEAKER_00: Press should be going down so I can buy more. We'll see you next time.

