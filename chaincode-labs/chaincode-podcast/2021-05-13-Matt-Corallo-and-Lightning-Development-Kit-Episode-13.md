---
title: Matt Corallo and Lightning Development Kit - Episode 13
transcript_by: Whisper AI & PyAnnote
categories: ['podcast']
tag: ['Starting Rust-Lightning', 'Language bindings challenges FFI', 'Interoperability of Lightning', 'Zero-value invoices', 'Keysend/push payments/spontaneous payments', 'What is the LDK stack?', 'Anchor Outputs Child pays for parent (CPFP)', 'Who tracks the onchain state when using LND?', 'LDK tracks the channel commitment transaction, how is that done? Compact block filters', 'Contrasting multiple implementations working from a spec in Lighting vs. no spec with one dominant reference implementation in Bitcoin The Lightning Spec', "What's the state of the Lightning Network? Have we moved beyond #reckless? Denial of Service (DoS) vulnerabilities Channel Jamming", 'Eltoo and the punishment dynamic', 'Will the network trend to trusted relationships and lend itself to KYC?', 'FATF updates its guidance on Virtual Asset Service Provider (VASP)', 'Where LDK goes from here?']
---

Chaincode Labs podcast: Matt Corallo and Lightning Development Kit - Episode 13

SPEAKER_02: talk about the tyranny of Linux maintainers and their shitty IP frag time default parameter.

SPEAKER_01: We could that does sound like a good starting point merge. Yeah, it doesn't seem excited about it

SPEAKER_00: Merge? Merge doesn't seem to...

SPEAKER_02: Yeah

SPEAKER_01: Welcome to the chain good podcast here with merch. Hey there. We are going to be talking with not Kerala, the blue mat.

SPEAKER_00: So today we're going to talk about the lightning development kit and what blue mat and compatriots have built why they had to add a bunch of language binding stuff and where like their kit ends and what you have to bring to you.

SPEAKER_01: Thanks for watching! use it. And just as a note, there are lots of acronyms thrown around in this conversation. So if you don't understand something, please do check out the show notes. We've tried to put timestamps and explain things on there. So please do check those out. Enjoy the episode. Welcome back to the office, Matt. Glad to have you back on the podcast. Thank you. We're going to start with L E K. Cool. Where are we at? What's going on?

SPEAKER_02: Thank you. you know, I guess as listeners are aware, so LDK kind of grew out of a project that I started a few years ago while I was working at ChainCode called Rust Lightning to, I mean, it kind of grew out of just my desire to play around with Lightning and learn more about it because I'd been contributing to Bitcoin Core but not really, didn't really know anything about Lightning. I think a common problem a lot of Bitcoin Core developers, at least at the time, were espousing. So, you know, I kind of started playing around with this and seeing what I could build. And then kind of slowly morphed into this idea of, look, there's no easy way to integrate Lightning into an existing thing. You can take L and D and run it, and then maybe you have a second wallet, maybe you're downloading the chain twice, but either way, it's kind of a separate process that you're running. It's not really kind of tightly integrated into whatever system you have. And I mean, the same is true for C Lightning, of course. And it kind of evolved into this desire to, like, help people integrate Lightning into existing platforms and especially existing mobile apps, like existing non-custodial wallets. You know, we built a great product there. We kind of square crypto, adopted the project, and started running with it about a year and a half ago, I guess, is when we got started on it. You know, we went around, spoke to a lot of wallets at the time, you know, got a lot of really great feedback. A lot of people said, like, yeah, that'd be great. I'd love to integrate Lightning, but the current solutions for integrating Lightning into our platform, whatever that platform is, are just, they're not workable. So we started down that path, but of course, immediately got a lot of feedback of, I want it to run in my platform, my platform being React native or some native Java thing on Android or some native Swift thing on iOS or XY, you know, whatever it is, you know, everyone wants it to be kind of native in their language.

SPEAKER_00: thing. Let me try to catch up everyone else here. You're building a library in Rust, and the idea is to make it usable for all sorts of other languages, as if it were a native library for those.

SPEAKER_02: Yeah. So we have the core is written in Rust, and then we have different sample implementations or kind of bits of, you know, we have a number of different interfaces, right? So it's a lightning library, not a lightning node. And so things like how you write the C to disk, how you keep it backed up, that kind of stuff is all dynamic and pluggable and there's just an interface for it and you have to do that yourself. But then we have, of course, a number of different implementations that you might use off the shelf or as sample implementations in a number of different languages. So we invested an inordinate amount of time building language binding support and are in a state that we're really proud of. I took a lot more work than I ever guessed. Turns out basically all of the language bindings systems that exist that we came across in our research are really designed to stub out a function, right? So you have, you know, some complicated function that maybe takes a long time to run and you simplify it into a pure function, probably, you stub that out into C or into some other language, and then you call that from whatever your host language is, they're really not designed for a full object oriented interface with interfaces that the user might be able to plug into and that kind of thing, and especially as far as I'm aware, no language binding systems except for the one that we built are really designed to map different memory models, right? So LDK and Rust Lightning are written in Rust and Rust has very clear object ownership semantics. Something owns an object you can optionally have, but you generally don't use things like atomic reference counted things and a lot of references flying around. You have, you know, you have references for short periods, but they have clear ownership semantics. This being exactly the opposite of languages like Java, JavaScript, etc. Where basically everything is an atomic reference counted pointer, a shared pointer in C++ terminology, and it's assumed that everything just takes another reference count to this object and there's no clear ownership semantics anywhere, and so you really have to do a lot of work to map. If you have some Rust library and then you have Java objects that own these things, you have to really map those ownership semantics correctly and do a lot of work at the FFI boundaries. And so we spent a lot of time building out stuff like that, but we're really happy with where we ended up. We do have pretty good Java bindings. Now we have Swift bindings, we have C and C++ bindings. We're working on JavaScript bindings, so we're happy with where we ended up, but it took about a full year to really get there.

SPEAKER_00: in ord- Reference

SPEAKER_01: Is there ongoing maintenance as you upgrade the library? Is that something that you have to continue to pay attention to?

SPEAKER_02: Yeah, so we've really, over the last few months, we've gone from, you know, we had demo applications written in Rust to we have users working on integrating LDK into their system in other languages, at least in a few cases, Java. That's obviously, once you really get the first external people playing with that rich API, you find all kinds of stuff of like, oh, this API is confusing. This isn't clear. The easy way to do this is wrong, like blah, blah, blah. And so we've been doing a lot of work on that front as well over the past number of months to really clean up the API and make sure that the easy way to do things or the way that you might naively do things if you don't read the talks closely enough is also the right way and the safe way to use the library. So we've been doing a lot of work on that front, of course, also keeping up with the lightning spec, which changes, although slowly, but you know, we've been doing so we have a lot of things that we're trying to juggle right now.

SPEAKER_01: And how do you sort of think about interoperability with the other projects? Because that's clearly something that is an issue in the ecosystem.

SPEAKER_02: You know, yeah, lightning, it's, it's interesting, right? Because the kind of the core of lightning is pretty robustly interoperable across all the implementations that exist, or at least that are kind of actively maintained. But the edges have ended up very fragmented, right? So you look at, and there's like brand names for all of the different things, but you look at like zero value invoices, right? So you generate an invoice with a zero value attached to it. And some clients will treat that as any value, right? So you enter a value or the sender enters a value. Some clients just treat that as zero. Some clients just fail. So that's one thing. Yeah. And there's kind of a lot of these kind of like little quote unquote features that have been added to different clients and they may be interoperable. They may not be interoperable. And it depends on the UX and what client you're using. And so there are, you know, there are some issues that have cropped up there, but at the same time, you know, this is also the experimentation phase of lightning, right? So you have different clients doing different things and experimenting and then slowly those things go back to the spec. And so you can look at like the, the push payments stuff. I think the common brand name for it is Keysend and that's something that was experimented on, there are a few different designs and a number of clients have adopted now a common implementation of that, but also it'll probably be replaced with something else that's a little better that ends up kind of in the formal spec, you know, part of it's like, well, it results in kind of a crappy UX right now in a lot of these ways, and also it's just these features that kind of slowly migrate from experimentation and weird cross compatibility issues towards the spec and towards people agreeing with, well, yeah, we tested this, we've experimented with it. We found something that works really well. And now it's in the spec and now, so because we've had so many other priorities, we haven't been as active in the experimentation area. That's also something where, you know, we have a fairly flexible API and you can do a lot of that experimentation kind of at the next level. So if you just take LDK and use it to build an app, you can experiment a lot with different potential lightning features, you know, that's something that we just haven't spent as much time on as we probably should be, but we'll get back to that as we round out some of the language bindings features that we've been working on, but, you know, we have been keeping up with the spec.

SPEAKER_00: Thanks for watching! You know- How does that plug in? So you run a Bitcoin core or some other Bitcoin software outside. You have your maybe business logic somewhere else, and each of that then just makes calls to the LDK library. You mentioned that you have a broad and evolving interface. Have you thought about versioning that already because eventually lightning will evolve too, or how does that work?

SPEAKER_02: Yeah, it is a little bit dependent on the exact thing. We've been doing it case by case largely. It depends a lot on like, okay, here's this new part of the spec or change in the spec and what are the requirements for doing that and using this new part of the spec so that the spec has negotiable features so you can negotiate with your peers, like I support this, I don't support that, and then you can use whatever features you commonly support. For each of those, we have to address like, okay, well, what's the point of this spec feature? You know, does it fix some problems? Does it prevent some attacks or is it just a nice thing to have? And what are the drawbacks and complexities of adding that? So, you know, you look at something like anchor outputs while lightning without anchor outputs, you're playing this weird game where you're trying to predict future fee rates and you have no idea what those are going to be. You're trying to predict the future fee rate that you need to hit at the time your counterparty selects to maybe cheat on chain, which is like an impossible problem. And so there's this anchor proposal to basically use CPFP to allow you to broadcast a transaction that has a lower fee rate, but then actually use CPFP to increase it, its effective fee rate. Exactly.

SPEAKER_00: have I have no idea what those are gonna be. Basically, bring your own fees.

SPEAKER_02: right basically bring your own fees but if you imagine a lightning wallet of course in order to bring your own fees you have to have an available on-chain output to spend into this CPFP transaction and so there's like a lot of additional complexity in the API right we have to require that users have available on-chain outputs but at the same time it fixes a relatively arguably critical bug in lightning's overall design and when you have any kind of material fee rate as we've been seeing in the mempool over the past whatever months i guess you know lightning has relatively critical security issues you know these kind of decisions are hard and we have to weigh like do we want to require and only support anchor do we want to support both i mean this is common you see like LND is asking a lot of their users right now whether they should only support anchor and require anchor or whether the cost of always having an on-chain output is too much for their users it's a really tough question but it also is very case by case because the trade-offs of like what is the API complexity versus what is the benefit of it is really what we have to weigh

SPEAKER_00: design. Fury. now You said that it's mostly mobile wallets that are currently playing around with LDK integration. Who tracks the on-chain state here for Lightning? Is that the LDK? Is that the mobile client? How do they get the- Yeah, so-

SPEAKER_02: Yeah. So, so our, our line in the sand is as long as the output on chain could potentially be spent by your counterparty, we deal with it. The second that the output on chain is yours kind of just solely yours, whether it's, I mean, whatever the script form is, as long as it's just solely yours, we hand it to the user and say, Hey, this is yours. Spend it as you see fit. Right. So, so we don't do direct on chain. We don't do like kind of a normal on chain wallet where you handle normal on chain payments. So there's plenty of libraries for that in any language you find. So we're not going to try to, not going to try to reinvent the wheel there. Certainly we handle any kind of punishment if your counterparty broadcasts an old state, anything like that. But once we get it to a point where it's just our funds, we just give you information, enough information to spend it and you do what you want.

SPEAKER_00: Thanks for watching, and I'll see you in the next video! The LDK's code takes care of tracking the channel commitment transactions. Yep. Does that happen via client-side block filters or what do you use?

SPEAKER_02: Yep. That's another area where we have a flexible API, uh, so we don't demand anything specifically, uh, or we actually now have two different APIs. We have one for kind of, uh, Electrum style, where it's all about the transactions and then we have one for SPV or full node style, where it's all about like, I download all the headers and I connect them in order and blah, blah, blah. So yeah, I mean, it's just, it's just an API at the end of the day. You can, you can do it in this SPV forum where you just make a call. That's a pure block is connected and you either have transaction data or optionally you don't, we give you all the information you might need to do, uh, you know, compact block filters. If you're doing that, uh, we give you all the information for Electrum. If you're doing something like that, where you just want to ask a server for a set of transactions related to your channel and we give, either way, we give enough information. We do have a sample that will do a sync against Bitcoin Core's RPC interface or Bitcoin Core's REST interface. Uh, so if you want to use that, you can just take that off the shelf and run it. Otherwise, you know, we assume you have that because that exists in, again, there's libraries for that nearly every language, uh, so we're not going to reinvent the wheel, you just have to integrate them.

SPEAKER_00: Thanks for watching! You might You have that. So basically, bring your own blockchain data as well.

SPEAKER_02: bring your own blockchain data.

SPEAKER_01: So you have spent most of your time in Bitcoin working on Bitcoin Core, and now you've transitioned to a different kind of project that has a spec that people open PRs to and have conversations about, which is very different. And then there's also this environment of multiple implementations as opposed to one reference implementation that dominates the network. What are the pros and cons of that dynamic?

SPEAKER_02: It's interesting because, you know, on one hand, it's still this kind of living, breathing open source project where you have to work with a number of other people to agree on what makes sense and you make a proposal and then other people decide yes or no, it's maybe a little kind of higher threshold for proposals because unlike Bitcoin Core where you might make a proposal in the form of a pull request and then people have to review it, now it's you make a proposal in the form of a pull request to the spec in English, presumably you've implemented it in your own implementation as well, but in order for other people to agree to it, they have to go implement it themselves, right? So it's no longer like, here I've got code, look at the code, it's here I've got English. If you agree with it, now you have to go also write code and like there's several implementations and presumably several people have to go write code and then also get that reviewed. So they might...

SPEAKER_01: So they might be interpreting that English in a very different way. I mean, does that happen?

SPEAKER_02: Yeah, and certainly that's, that's also been an issue for lightning in the past. It's gotten a lot better, but there were a number of issues early on. And you know, you still find things occasionally where if two implementations disagree on either the current state of the channel or the rules about what you can and can't do in a channel, they'll force close and that can be a relatively critical denial of service vulnerability on the network, right? So if you imagine see lightning and LND have understood the English of the spec slightly differently in some context and think that the rules of the game are slightly different, then a user might be able to forward a payment across any see lightning to LND or LND to see lightning channel and cause them to close the channel and potentially split the network, right? It's a split brain, the, the lightning network such that no one can relay a payment between see lightning or LND or LND and Eclare or Electrum and Eclare or whatever it is fraught with those kinds of issues. And that's something that is really tough to get right. And lightning being basically, there's a lot of things to do with lightning. Basically like, you know, it was written, there's this thing it's working, but there's a lot of edge cases and a lot of things that

SPEAKER_01: Thanks for watching!

SPEAKER_02: really need tuning. Part of it can't really be tuned until there's real world experience with people running this thing and people testing it, and that's something that's being gathered. Part of it's just a lot of work and really hard, like issues like this where you have to make sure that nodes exactly agree on what's going on, and maybe you can reduce likelihood of these kinds of issues with certain countermeasure strategies. But it is a very different world from Bitcoin Core in that sense. You still have, you know, with Bitcoin Core, you're really worried about issues where you might split the network between old versions and new versions of Bitcoin Core, but at least it's the same code base, so you can review a patch. Again, you can review an individual patch and say like this in the patch might split between something that does have this patch and this is something that doesn't have this patch, not, okay, now I have to go read some Go code and some C code and some Rust code and some Python code and make sure they are all doing the same thing.

SPEAKER_00: Thanks for watching! hard.

SPEAKER_01: And I guess you've been talking about different vulnerabilities and denial of service and lightning. Like what's the state of the network now? Have we moved beyond reckless? Are we, how robust is this?

SPEAKER_02: I mean, I guess it's a question of like, what's your pain threshold really? You know, is a denial of service vulnerability a critical issue? Well, no, I mean, you're not going to, you're probably not going to lose money, right? The two ends of the channel aren't losing money. They're just forced closing the channel of the chain and they're going to figure out who has the money. At the same time, suddenly people's payments might fail, right? You're going to break routing in the network. Luckily we haven't seen these kinds of attacks exploited, of course, there's maybe more obvious ways you might denial of service to network. The issues around kind of filling the available capacity of channels are much more broadly discussed and much more readily visible and also difficult to, to protect against. Again, not something we've seen materially exploited, but if you're really relying on this thing to always work a hundred percent of the time, well, maybe that's not quite where we are today.

SPEAKER_00: the time, well.

SPEAKER_02: At the same time, I mean, we talked a little bit about anchors as something that's really important for ability to ensure if your counterparty does broadcast a transaction that you can appropriately punish them if they're broadcasting an old state or revoked state. And that's something that's, I think at this point, either optionally or by default in many lightning implementations, if not most, and people are going back and forth on whether to require it. I mean, it materially harms the UX of lightning, right? You always have to have this on chain output. You can't build a lightning wallet that is only lightning and that holds all of its balance in lightning, which was kind of a model that a lot of people wanted to do because it's great, right? You should be able to always send your entire balance if you want to, or you should be able to have that entire balance available in the way that you expect to not have this like weird small part of your balance that's always on the side and you can't really use it and it's just kind of sitting there. There are still a lot of issues to figure out in lightning. For the most part, people open channels with counterparties that they not really trust, but trust to not go like deliberately modify their software and do all kinds of these crazy attacks that are, you know, fraught with requirements and edge cases. So it's not really a problem in practice, but you know, if you're talking about really opening a channel with someone who you think is potentially actively malicious, you might want to think twice.

SPEAKER_01: want to think twice are you actually observing cheaters on the network is that happening?

SPEAKER_02: I think for the most part we haven't seen much. Certainly there are occasionally, you know, someone might restore an old backup or what have you and accidentally broadcast an old estate. I'm not aware of any cases where someone has, you know, performed any of these kinds of long-range poor fee estimation attacks that anchor and such prevents. You know, they are much more complicated and there's lower hanging fruit. So, you know, I don't think we've seen that. We also haven't seen channel jamming. It's something that gets talked about on the mailing list left and right and academic papers written about it and what have you. So it's not like it's not out there. It's not like people aren't aware of the potential for someone to kind of denial service attack the lightning network. But for the most part, we just haven't seen it because, you know, why bother? We know it's a problem. It's, you know, people are working on fixing it. If it did happen, payments would get stuck for a while and then people would kind of work around it a little bit. But...

SPEAKER_00: You

SPEAKER_02: Also, you know, it's just it's it's one of these kind of griefing attack denial of service things So there's a lot of issues to solve but it's also not something that's kind of harming the immediate UX that people have today.

SPEAKER_01: I wanted to go back to the punishment dynamic and clearly with L2, those dynamics change. It doesn't look like L2 is going to be around the corner given how hard soft forks are. But I'd be sort of interested in your take on punishment versus like a little bit more forgiving dynamic with L2.

SPEAKER_02: Hmm. Yeah, I mean, that's a really good question. I would hope that there is some cost, you know, certainly it can't be the case in order to update the state on chain in L2 for someone who's trying to, who broadcasts an old state, that the only cost of updating that state is on the person who's trying to update the state and trying to go back against the counterparty because on chain fees can be non-trivial. And so, you know, there has to be something to offset that, whether that's, you know, a high fee, a hundred percent of the channel, like punishment is now, or, you know, whatever it is. You know, there's got to be something there, but, you know, how to find the right value is a tough question.

SPEAKER_00: You know, there's gotta be something there.

SPEAKER_01: Thanks for watching!

SPEAKER_00: How would you even push for a punishment in L2 where the update transactions are symmetric then? Wouldn't you have to reintroduce asymmetry then?

SPEAKER_02: Yeah, that's a good question. I don't know offhand, it's possible you might have to reintroduce asymmetry. I don't know that that's necessarily the worst thing in the world, you know, as long as you still have, you know, the big win with L2 is of course that you don't have to store old states, you can just store one state. Having to store two states is not very different from one state, as long as you don't have to store n states. So maybe there's a way to do that. I haven't dug into that kind of thing. Yeah, I mean, you have to have something, right? You can't just say like, well, if someone broadcasts an old state, the counterparty has to spend on-chain fees and a CPFP in order to get to the latest state, because again, on-chain fees can be non-trivial and you are exposed to some amount there. So you have to do something, but it's unclear exactly how you would require that.

SPEAKER_00: Thanks for watching! I mean, you have to- I've seen a few times the argument being made that while you sort of have to trust your channel partners, they infer from that that the network is going to trend more to trusted relationships, at least for the major channels, and that it may become overlaid with KYC. Is that something that concerns you?

SPEAKER_02: Is that something that Not really. A lot of the, you have to trust your counterparty to not deliberately cheat in order to not lose money, things are things that we can fix, things that are fixed by things like anchor and that kind of stuff. The more interesting cases that we've seen a lot more recently are around things like accepting, you know, if you have a mobile wallet and you get an inbound payment that the vendor of that mobile wallet might run a node that opens a channel to you for that inbound payment and that the UX of the mobile wallet just goes ahead and displays like, yes, you've received this payment, even though the channel is still zero conf, right? So trusting the vendor of the mobile wallet to not double spend you, right? This is like a fairly reasonable thing, significantly improves the UX, doesn't require any KYC. I mean, it's just trusting the vendor of the mobile wallet. You know, we'll see more stuff like that, but it doesn't necessarily require KYC for that type of interaction. And certainly, you know, if you're opening a very large channel, yeah, you probably want to know your counterparty is, but you don't necessarily need to KYC them so much as like, well, it's a another business that I know, or it's a friend of mine or whatever, you know, we're not, we're not really talking about.

SPEAKER_00: You're reasonable.

SPEAKER_02: that kind of level of the issue. And the other thing there are things you can do around, you know, especially on mobile, there's things you can do around like, well, potentially I know that you're actually running my app and so hopefully you're not going to be able to modify the app or something.

SPEAKER_00: This week I think there was an update to FATF and it was very confusing about whether or not users are VASPs or not and so forth. Another thing that gets brought up with Lightning often is will users in the Lightning Network that forward transactions become regulated or is that something that you guys are thinking about when you're building out your software?

SPEAKER_02: It's not something we're worried about, that's not also not our domain, that's more the domain of really advocates, not because it's, I think it's understood that that's not really the current policy. There's no, as far as I'm aware, no regulators have tried to push that as policy. There is uncertainty about it, because regulators certainly haven't kind of clarified that that's absolutely never going to happen. But that's a question for policy advocates, less us developers or potentially even lawyers. There's a lot of issues with where the puck is going for regulation around Bitcoin payments. A lot of users, certainly almost everyone gets into Bitcoin by buying Bitcoin on some centralized platform. And those are really obvious choke points. And that's, I think, the key area that people like FATF are going after and really targeting and then trying to also bring basically any other named entity they can under those kinds of regulations. So, you know, there's a world where they try to argue any lightning node is also bound by those regulations. That's not really materially different from them arguing that every node is bound by those regulations, or that anyone who has a wallet is bound by regulations that say they have to KYC their counterparty. From a technical perspective, they can argue that, but it doesn't really change anything, right? Like if you're a Coinbase or someone and you're running a lightning node, and FATF says any payment you send or receive, period, including on your lightning node needs KYC, well, that's a problem in and of itself. The fact that lightning is related is kind of, well, it's unrelated. You see things like various mixing services, decentralized mixing services. Well, yeah, regulators would love to shut that down, but at the end of the day, it's just this kind of pure technical thing that exists, and you can't really go after that directly. I think the same is true for lightning, the same is true for Bitcoin broadly, the same is true for a lot of these decentralized mixers, but the real question is what kind of KYC requirements are they going to try to apply to anyone making a Bitcoin transaction and to these exchanges that people buy from, you know? Are you going to be able to withdraw your coins onto your own wallet without having to KYC anyone you ever transact with? Those kinds of issues are big questions. How that applies to lightning is, I mean, like, yeah, it could apply to lightning, but so what? Because it applies to everything, and that's a problem in and of itself. It doesn't really, you know, it's not specific to lightning.

SPEAKER_00: It's unrelate. Mm-hmm.

SPEAKER_01: You know. Where does LDK go from here?

SPEAKER_02: Yeah, so we have spoken to a number of, especially mobile wallets. I think that's kind of currently our bread and butter because we do have a much lighter weight implementation and something that just integrates, is designed to integrate versus, you know, a lot of the other lightning implementations are not. We've got a number of people who've been playing around with LDK and exploring integration and starting to work on it. It's all early, you know, obviously, even if you have LDK doing most of the back-end work for you and implementing lightning for you, you still have to update your UX and update how you handle, you know, how you show payments, how you scan QR codes, all that kind of stuff. So, you know, I mean, it's still work. It's not, it doesn't come for free as much as we would like it to come as free as possible. That's continuing. We're continuing to talk to people. We're still interested in anyone who wants to integrate lightning into a system where they don't already have lightning or they want something that integrates a little tighter with their system than L and D or C lightning where you run this binary and then you make our PC calls to it. You know, we're interested in chatting with people. They can check out our website, come to our Slack. You know, we're currently, because we're still tuning the API to ensure that it's good for users, we're very hands-on, right? So when someone comes to us and is like, I want to integrate it in this way, we are pretty active in responding and helping them in many cases. You want something to integrate lightning, you know, come chat with us. We're happy to be very active and very hands-on if you want us to be. Yeah, the square crypto team for free, right? Isn't that how that works? Yeah. I mean, basically you get, you know, some free, some free engineering hours. Cool.

SPEAKER_00: It's the sun.

SPEAKER_01: even. Yeah, the square crypto team for free, right? Yeah.

SPEAKER_00: Well, thanks Matt that was insightful. Yeah

SPEAKER_01: Hope you enjoyed the episode, and please do check out our show notes. See you next time.

